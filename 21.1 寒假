Day1 
//今天份的不想学习
//只做了四道题，剩下一道图论一道线性动态规划之后补

T1 ： https://codeforces.com/problemset/problem/1472/A
题意：给出纸张的长和宽，只有偶数可以继续裁剪。最终能够得到的纸张数是否大于等于指定数目。
思路：很显然最终可以得到的纸张数=裁剪“长” * 裁剪“宽”， 转化为求一个偶数最终能够分为几个奇数————一直除2看能除几次，然后根据（我没有的）数学知识是求2的次幂，怕卡时间写了快速幂
//也不知道说的啥，上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

long long ans;
long long poww;
long long h, w, n;
int t;

long long kpow(long long _poww) {     //变量名实在太丑了点
    long long _ans=1;
    long long b=2;
    if(_poww==0) {
        _ans=1;
        return _ans;
    }
    while(_poww>0) {
        if(_poww&1) 
           _ans=_ans*b;
        b=b*b;
        _poww=_poww>>1;
    }
    return _ans;    //这是快速幂的部分（无情的模板机器
}

long long doit (long long x) {
    poww=0;
    while(!(x&1)) {        //位运算稍微快一点点
        x=x>>1;
        poww++;            //这个是看可以除几次2
    }
    return kpow(poww);
}

int main() {
    scanf("%d", &t) ;
    for(int i = 1; i <= t; i ++) {
        scanf("%lld%lld%lld", &w, &h, &n);
        ans = doit(w) * doit(h);
        if(ans >= n) {
            printf("YES\n");
            continue;
        }
        printf("NO\n");
    }
    return 0;
}
//啊签到题罢辽(但是说不定还有简单做法？

T2 ： https://codeforces.com/problemset/problem/1472/B
题意：给出一串只有1和2的序列，判断是否可以把这个序列分成两个子序列，使两个子序列的所有数之和相对（我也不知道在说啥反正就这个意思
题解：突破点其实在这一串数只有1和2来着（一开始没看见吓死了），稍微要想一下。如果这一串数满足，应该有以下几点特征：
      1.所有数之和不能是奇数，必须是偶数
      //然后思考如果是偶数就一定满足了吗？
      //和是偶数的话，说明1的数量一定是偶数，2的数量可能是奇数可能是偶数。
      //如果2的数量是偶数，那就一定可以，最起码存在两组分别有一半1和一半2；如果2的数量是奇数，设2的数量是y,1的数量是x,满足要求的话也就是2y-x可以对半分，啊那就显然可以。
      //然后注意特殊情况，1的数量是0的话，2的数量是奇数也不行
      2.1的数量为0时，2的数量不能是奇数

//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100010

int t;
int n;
int w[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        scanf("%d",&n);
        int two=0;
        int one=0;
        int ww=0;
        for(int j=1;j<=n;j++) {
            scanf("%d",&w[j]);
            if(w[j]==1) one++;
            if(w[j]==2) two++;
            ww+=w[j];
        }
        if(ww%2==1) {
            printf("NO\n");
            continue;
        }
        if((one==0)&&two%2!=0) {
            printf("NO\n");
            continue;
        }
        printf("YES\n");
    }
    return 0;
}
//稍微还是有点难想吧，题做多了可能敏感度就上来了（？）

T3 ： https://codeforces.com/problemset/problem/1472/C
题意：给出数字序列，下标从1开始，随机选一个下标i开始走，value加上a(i),下一步走到i+a(i),直到走到没法再走。要找出这个下标，使结束时的value最大。
思路：第一反应可能是模拟，一个一个扫过去，但是时间复杂度就很高。所以想到倒推，value[i]=a[i]+value[i+a[i]]
//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

int t=0;
int n=0;
int a[MAXN];
int dp[MAXN]={0};
int ans=0;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            scanf("%d",&a[i]);
        }
        ans=0;
        for(int i=n;i>=1;i--) {
            if(i+a[i]<=n) {
                dp[i]=a[i]+dp[i+a[i]];      //并不是动规，稍微被误导了以下
            }
            else {
                dp[i]=a[i];
            }
            ans=max(ans,dp[i]);
        }
    printf("%d\n",ans);
    }
    return 0;
}
//不太难，偶尔还是要自己想一想感受一下脑子的存在

T4 ： https://vjudge.net/problem/CodeForces-1472/D
题意：奇偶游戏。Alice选偶数加分，Bob选奇数加分，同时两人也可以ban掉对方选的数，当两人最佳发挥时，谁可以最终赢得比赛。
思路：首先思考最佳发挥是怎么发挥法。Alice要总能选到对自己有利的数，每一回合要决定pick还是ban，最终的目的是赢，贪心看，比较pick的数较大还是ban的数较大，就可以确定是ban还是pick；Bob同理。
      所以要对偶数和奇数分别进行排序，然后从大向小遍历。
//还是简单粗暴的上代码写注释

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

int t;
ll totA,totB;
ll jishu[MAXN],oushu[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        int n;
        scanf("%d",&n);
        int ji=1,ou=1;
        for(int j=1;j<=n;j++) {
            ll num;
            scanf("%lld",&num);
            if(num%2==1) {
                jishu[ji]=num;        //奇数和偶数分别放在不同的数组里
                ji++;
            }       
            else {
                oushu[ou]=num;
                ou++;
            }
        }
        sort(jishu,jishu+ji);
        sort(oushu,oushu+ou);
        ji--;
        ou--;   
        totA=0;
        totB=0;
        for(int j=0;j<n;j++) {
            if(j%2==0) {   //Alice的回合
                if((ou==0)&&(ji>0)) {    //如果偶数已经选完，那现在势必是要ban掉奇数
                    ji--;
                    continue;
                }
                if(jishu[ji]<oushu[ou]) {    //如果没有选完，并且pick比ban更有利
                    totA+=oushu[ou];
                    ou--;
                }
                else {
                    if(ji>0) ji--;
                }
                //printf("%lld\n",totA);
            }
            else {
                if((ji==0)&&(ou>0)) {     //Bob同理
                    ou--;
                    continue;
                }
                if(jishu[ji]>oushu[ou]) {
                    totB+=jishu[ji];
                    ji--;
                }
                else {
                    if(ou>0) ou--;
                }
            }
        }
        if(totA>totB) printf("Alice\n");
        if(totA<totB) printf("Bob\n");
        if(totA==totB) printf("Tie\n");
    }   
    return 0;
}

//稍微想一下下，关键在怎么才是最佳发挥

T5 ： https://vjudge.net/problem/CodeForces-1472/E
//这个是后来补的题
题解：就是给出几个矩形的长和宽，然后判断这个矩形是否可以将某个矩形完全覆盖（不包含等号），如果可以就输出被覆盖的矩形的索引，如果没有，就输出-1.
思路：题目中说给出的矩形的“长”和“宽”不一定哪个大，啊啊不知道怎么说。反正根据小学生思维，大的就看作长，小的就看作宽，那其实就无所谓比较的方法了（题目里说的站着或躺着），就可以直接分别比较
    两组数据里较小的和较大的。肯定不能一个一个挨个比啊，直接按照矩形的长把数据排序，只要那么对于第i个矩形是满足条件的矩形，就是1~i-1个矩形里最小的宽比第i个矩形的宽小（啊数学的存在与恒成立
    问题）。然后考虑特殊情况，可能会这样，就是说前面有一个长和宽都比当前这个矩形b小的矩形a，但是现在这个前面有一个长和b一样但是宽比a还要小的矩形c，那么最后找到的可以放在b上矩形是c，但这样是
    错误答案。为了避免这种情况的发生，把相同长的矩形按照宽降序排序。
    以及返回索引应该要存储原来数据的顺序。
#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
#include<math.h>

using namespace std;

struct Node {
    int maxx,minn;
    int num;          //用来存储原来的顺序
    int ans;
}mat[200010];               //涉及到多个关键词排序，用sort的话需要建立结构体

int t;
int n;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int min(int a,int b) {
    if(a<b) return a;
    return b;
}

bool cmp1(Node a,Node b) {
    if(a.maxx!=b.maxx) return a.maxx<b.maxx;
    return a.minn>b.minn;
}

bool cmp2(Node a,Node b) {
    return a.num<b.num;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            int h,w;    
            scanf("%d%d",&h,&w);
            mat[i].maxx=max(h,w);     
            mat[i].minn=min(h,w);      //转换长和宽
            mat[i].num=i;
            mat[i].ans=-1;
        }
        sort(mat+1,mat+1+n,cmp1);
        int _min=1;             //标记当前最小的宽在排好序的数组里的索引
        for(int i=2;i<=n;i++) {
            if(mat[i].minn<mat[_min].minn) {
                _min=i;
            }
            if(mat[i].minn>mat[_min].minn) {
                mat[i].ans=mat[_min].num;
            }
        }
        sort(mat+1,mat+1+n,cmp2);      //按照num排序，也就是回到原来输入的顺序
        printf("%d",mat[1].ans);
        for(int i=2;i<=n;i++) {
            printf(" %d",mat[i].ans);        //不要末尾空格
        }
        printf("\n");
    }
}

//做出来感觉也不咋难（？）

T6 ： https://codeforces.com/problemset/problem/1472/F
//传说中的线性动态规划，不会做，之后补
//嘤我还找规律了结果是错的
//因为不会所以没有题解


T7 ： https://codeforces.com/problemset/problem/1472/G
//显然是道图论题，题目都么的看呜呜呜
//之后有机会补
//图论怎么可能有题解呢（划掉）

Day 2

T1 :  https://codeforces.com/problemset/problem/1454/A
题意：给出数字n，要求对1~n之内的数字进行排列，要求排列得到的数列arr[i]!=i。
思路：题意比较简单，类比之前有道题（啊自己写的深搜递归）是输出1~n之内所有数字所有排列方法，可以用同样的方法对每一位的数字枚举递推，到最后一位数都满足条件，就输出得到的这个数列，同时标记
    已经得到过了，之后的深搜不用往下搜了。
//肯定还有更简单的办法

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

int arr[110];
int flag=0;
int f[110]={0};

void doit(int n,int cnt) {
    if(cnt==n+1) {
        flag=1;
        printf("%d",arr[1]);
        for(int i=2;i<=n;i++) {
            printf(" %d",arr[i]);
        }
        printf("\n");
        return ;
    }

    for(int i=1;i<=n;i++) {
        if(!f[i]&&(cnt!=i)&&flag==0) {     //这个数没有排列过&&arr[i]!=i&&还没有得到过正确的数列
            arr[cnt]=i;
            f[i]=1;
            doit(n,cnt+1);      //继续往下搜
            f[i]=0;                     //状态还原
        }
    }
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {    
        int n;
        scanf("%d",&n);
        flag=0;
        doit(n,1);
    }
    return 0;
}

T2 ： https://codeforces.com/problemset/problem/1454/B
题意：给出一列数字，玩家随机选择索引，获胜者的索引有这样的特征————这个数字在数列中只出现了一次，并且这个数字是所有只出现过一次的数字中最小的数字
思路：水水水水题。sort排个序，存储原来的下标，遍历就完事。
//然后猛然发现我这题居然错了一遍！惊了！！！
#include<cstdio>

int main() {
	int n,t;
	int a[200010],tem,a2[200010],s=0;     //直接把输入的数字作为下标
	scanf("%d",&t);
	while(t--) {
		s=0;
		scanf("%d",&n);
		for(int i=0;i<n+1;++i) {
			a[i]=0;
		}
		for(int i=0;i<n;++i) {
			scanf("%d",&tem);
			a[tem]++;     //存储出现的次数
			a2[tem]=i+1;        //存储在原来序列中的下标
		}
		for(int i=1;i<=n;++i) {
			if(a[i]==1) {
				printf("%d\n",a2[i]);
				s=1;
				break;
			}
		}
		if(!s) {
			printf("-1\n");
		}
	}
	return 0;
}
//sort都没用，一个O(n)的算法，用sort就升成O(nlogn)了
然后改我原来的破代码
//这个是wa掉的（用了结构体）交的时候想着这把必过呜呜呜
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

struct Node {
    int index,numb;
    int p;
}arr[MAXN];

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        for(int i=1;i<=MAXN;i++) {     //啊Σ(っ °Д °;)っ做了标记的这两个地方，有等于号会wa掉第三个点
            arr[i].p=0;
        }
        for(int i=1;i<=n;i++) {
            int num;
            scanf("%d",&num);
            arr[num].numb=num;
            arr[num].index=i;
            arr[num].p++;
        }
        int flag=0;
        for(int i=1;i<=MAXN;i++) {	//没有等于号又会t掉第四个点   如果把MAXN换成n就又对了   (っ °Д °;)っ到底是怎么肥四啊啊啊啊
            if(arr[i].p==1) {
                printf("%d\n",arr[i].index);
                flag=1;
                break;
            }
        }
        if(!flag) printf("-1\n");
    }
    return 0;
}
//鸽掉，明天看

T4 ： https://codeforces.com/problemset/problem/1454/C
题意：（题目肯定不是这么描述的，自己提炼一下）给出一组数，选择某个数列中存在的数（必须是全部的位置）把这一列数分割成若干组，问最少可以分出几组（不包含选出的数）
	I can't write Chinese.wuwuwu 啊好了，这其实跟题目表述的选择一个数i，每次去掉全部数列中不包含这个数的子列（连续且完整），问最少的操作数后可以使数列中的数全部相同
思路：根据提炼出来的意思只需要找每个数出现了几次，同时注意特殊情况————某个数连续出现，某个数出现在开头或结尾，这两种情况对最后的统计都有影响
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

using namespace std;

int arr[MAXN];
int p[MAXN];

int min(int a,int b) {
    if(a>b) return b;
    return a;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        memset(arr,0,sizeof(arr));
        memset(p,0,sizeof(p));
        int n;
        scanf("%d",&n);
        int _n=n;
        for(int i=1;i<=_n;i++) {
            scanf("%d",&arr[i]);
            if(i!=1) {
                if(arr[i]==arr[i-1]) {     //去掉连续的，看完我都惊了Σ(っ °Д °;)っ，真的学到了学到了
                    i--;
                    _n--;
                }
            }
        }
        for(int i=1;i<=_n;i++) {
            p[arr[i]]++;
        }
        int ans=999999;
        if(_n==1) {
            printf("0\n");
            continue;
        }
        for(int i=1;i<=n;i++) {
            if(p[i]) {
                ans=min(ans,p[i]);       //某个数出现的次数最少，分割出的子列一定最小
            }
        }
        if(arr[1]==arr[_n]) {
            printf("%d\n",min(ans+1,p[arr[1]]-1));     //在一般位置，子列数是频数+1，在开头和结尾（这是同时出现的特殊位置）是频数-1
        }
        else {
            printf("%d\n",min(ans+1,min(p[arr[1]],p[arr[_n]])));     //只出现开头或结尾，子列数就是频数
        }
    }
    return 0;
}



















