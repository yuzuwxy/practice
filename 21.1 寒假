Day1 
//今天份的不想学习
//只做了四道题，剩下一道图论一道线性动态规划之后补

T1 ： https://codeforces.com/problemset/problem/1472/A
题意：给出纸张的长和宽，只有偶数可以继续裁剪。最终能够得到的纸张数是否大于等于指定数目。
思路：很显然最终可以得到的纸张数=裁剪“长” * 裁剪“宽”， 转化为求一个偶数最终能够分为几个奇数————一直除2看能除几次，然后根据（我没有的）数学知识是求2的次幂，怕卡时间写了快速幂
//也不知道说的啥，上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

long long ans;
long long poww;
long long h, w, n;
int t;

long long kpow(long long _poww) {     //变量名实在太丑了点
    long long _ans=1;
    long long b=2;
    if(_poww==0) {
        _ans=1;
        return _ans;
    }
    while(_poww>0) {
        if(_poww&1) 
           _ans=_ans*b;
        b=b*b;
        _poww=_poww>>1;
    }
    return _ans;    //这是快速幂的部分（无情的模板机器
}

long long doit (long long x) {
    poww=0;
    while(!(x&1)) {        //位运算稍微快一点点
        x=x>>1;
        poww++;            //这个是看可以除几次2
    }
    return kpow(poww);
}

int main() {
    scanf("%d", &t) ;
    for(int i = 1; i <= t; i ++) {
        scanf("%lld%lld%lld", &w, &h, &n);
        ans = doit(w) * doit(h);
        if(ans >= n) {
            printf("YES\n");
            continue;
        }
        printf("NO\n");
    }
    return 0;
}
//啊签到题罢辽(但是说不定还有简单做法？

T2 ： https://codeforces.com/problemset/problem/1472/B
题意：给出一串只有1和2的序列，判断是否可以把这个序列分成两个子序列，使两个子序列的所有数之和相对（我也不知道在说啥反正就这个意思
题解：突破点其实在这一串数只有1和2来着（一开始没看见吓死了），稍微要想一下。如果这一串数满足，应该有以下几点特征：
      1.所有数之和不能是奇数，必须是偶数
      //然后思考如果是偶数就一定满足了吗？
      //和是偶数的话，说明1的数量一定是偶数，2的数量可能是奇数可能是偶数。
      //如果2的数量是偶数，那就一定可以，最起码存在两组分别有一半1和一半2；如果2的数量是奇数，设2的数量是y,1的数量是x,满足要求的话也就是2y-x可以对半分，啊那就显然可以。
      //然后注意特殊情况，1的数量是0的话，2的数量是奇数也不行
      2.1的数量为0时，2的数量不能是奇数

//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100010

int t;
int n;
int w[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        scanf("%d",&n);
        int two=0;
        int one=0;
        int ww=0;
        for(int j=1;j<=n;j++) {
            scanf("%d",&w[j]);
            if(w[j]==1) one++;
            if(w[j]==2) two++;
            ww+=w[j];
        }
        if(ww%2==1) {
            printf("NO\n");
            continue;
        }
        if((one==0)&&two%2!=0) {
            printf("NO\n");
            continue;
        }
        printf("YES\n");
    }
    return 0;
}
//稍微还是有点难想吧，题做多了可能敏感度就上来了（？）

T3 ： https://codeforces.com/problemset/problem/1472/C
题意：给出数字序列，下标从1开始，随机选一个下标i开始走，value加上a(i),下一步走到i+a(i),直到走到没法再走。要找出这个下标，使结束时的value最大。
思路：第一反应可能是模拟，一个一个扫过去，但是时间复杂度就很高。所以想到倒推，value[i]=a[i]+value[i+a[i]]
//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

int t=0;
int n=0;
int a[MAXN];
int dp[MAXN]={0};
int ans=0;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            scanf("%d",&a[i]);
        }
        ans=0;
        for(int i=n;i>=1;i--) {
            if(i+a[i]<=n) {
                dp[i]=a[i]+dp[i+a[i]];      //并不是动规，稍微被误导了以下
            }
            else {
                dp[i]=a[i];
            }
            ans=max(ans,dp[i]);
        }
    printf("%d\n",ans);
    }
    return 0;
}
//不太难，偶尔还是要自己想一想感受一下脑子的存在

T4 ： https://vjudge.net/problem/CodeForces-1472/D
题意：奇偶游戏。Alice选偶数加分，Bob选奇数加分，同时两人也可以ban掉对方选的数，当两人最佳发挥时，谁可以最终赢得比赛。
思路：首先思考最佳发挥是怎么发挥法。Alice要总能选到对自己有利的数，每一回合要决定pick还是ban，最终的目的是赢，贪心看，比较pick的数较大还是ban的数较大，就可以确定是ban还是pick；Bob同理。
      所以要对偶数和奇数分别进行排序，然后从大向小遍历。
//还是简单粗暴的上代码写注释

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

int t;
ll totA,totB;
ll jishu[MAXN],oushu[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        int n;
        scanf("%d",&n);
        int ji=1,ou=1;
        for(int j=1;j<=n;j++) {
            ll num;
            scanf("%lld",&num);
            if(num%2==1) {
                jishu[ji]=num;        //奇数和偶数分别放在不同的数组里
                ji++;
            }       
            else {
                oushu[ou]=num;
                ou++;
            }
        }
        sort(jishu,jishu+ji);
        sort(oushu,oushu+ou);
        ji--;
        ou--;   
        totA=0;
        totB=0;
        for(int j=0;j<n;j++) {
            if(j%2==0) {   //Alice的回合
                if((ou==0)&&(ji>0)) {    //如果偶数已经选完，那现在势必是要ban掉奇数
                    ji--;
                    continue;
                }
                if(jishu[ji]<oushu[ou]) {    //如果没有选完，并且pick比ban更有利
                    totA+=oushu[ou];
                    ou--;
                }
                else {
                    if(ji>0) ji--;
                }
                //printf("%lld\n",totA);
            }
            else {
                if((ji==0)&&(ou>0)) {     //Bob同理
                    ou--;
                    continue;
                }
                if(jishu[ji]>oushu[ou]) {
                    totB+=jishu[ji];
                    ji--;
                }
                else {
                    if(ou>0) ou--;
                }
            }
        }
        if(totA>totB) printf("Alice\n");
        if(totA<totB) printf("Bob\n");
        if(totA==totB) printf("Tie\n");
    }   
    return 0;
}

//稍微想一下下，关键在怎么才是最佳发挥

T5 ： https://vjudge.net/problem/CodeForces-1472/E
//这个是后来补的题
题解：就是给出几个矩形的长和宽，然后判断这个矩形是否可以将某个矩形完全覆盖（不包含等号），如果可以就输出被覆盖的矩形的索引，如果没有，就输出-1.
思路：题目中说给出的矩形的“长”和“宽”不一定哪个大，啊啊不知道怎么说。反正根据小学生思维，大的就看作长，小的就看作宽，那其实就无所谓比较的方法了（题目里说的站着或躺着），就可以直接分别比较
    两组数据里较小的和较大的。肯定不能一个一个挨个比啊，直接按照矩形的长把数据排序，只要那么对于第i个矩形是满足条件的矩形，就是1~i-1个矩形里最小的宽比第i个矩形的宽小（啊数学的存在与恒成立
    问题）。然后考虑特殊情况，可能会这样，就是说前面有一个长和宽都比当前这个矩形b小的矩形a，但是现在这个前面有一个长和b一样但是宽比a还要小的矩形c，那么最后找到的可以放在b上矩形是c，但这样是
    错误答案。为了避免这种情况的发生，把相同长的矩形按照宽降序排序。
    以及返回索引应该要存储原来数据的顺序。
#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
#include<math.h>

using namespace std;

struct Node {
    int maxx,minn;
    int num;          //用来存储原来的顺序
    int ans;
}mat[200010];               //涉及到多个关键词排序，用sort的话需要建立结构体

int t;
int n;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int min(int a,int b) {
    if(a<b) return a;
    return b;
}

bool cmp1(Node a,Node b) {
    if(a.maxx!=b.maxx) return a.maxx<b.maxx;
    return a.minn>b.minn;
}

bool cmp2(Node a,Node b) {
    return a.num<b.num;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            int h,w;    
            scanf("%d%d",&h,&w);
            mat[i].maxx=max(h,w);     
            mat[i].minn=min(h,w);      //转换长和宽
            mat[i].num=i;
            mat[i].ans=-1;
        }
        sort(mat+1,mat+1+n,cmp1);
        int _min=1;             //标记当前最小的宽在排好序的数组里的索引
        for(int i=2;i<=n;i++) {
            if(mat[i].minn<mat[_min].minn) {
                _min=i;
            }
            if(mat[i].minn>mat[_min].minn) {
                mat[i].ans=mat[_min].num;
            }
        }
        sort(mat+1,mat+1+n,cmp2);      //按照num排序，也就是回到原来输入的顺序
        printf("%d",mat[1].ans);
        for(int i=2;i<=n;i++) {
            printf(" %d",mat[i].ans);        //不要末尾空格
        }
        printf("\n");
    }
}

//做出来感觉也不咋难（？）

T6 ： https://codeforces.com/problemset/problem/1472/F
//传说中的线性动态规划，不会做，之后补
//嘤我还找规律了结果是错的
//因为不会所以没有题解


T7 ： https://codeforces.com/problemset/problem/1472/G
//显然是道图论题，题目都么的看呜呜呜
//之后有机会补
//图论怎么可能有题解呢（划掉）

Day 2

T1 :  https://codeforces.com/problemset/problem/1454/A
题意：给出数字n，要求对1~n之内的数字进行排列，要求排列得到的数列arr[i]!=i。
思路：题意比较简单，类比之前有道题（啊自己写的深搜递归）是输出1~n之内所有数字所有排列方法，可以用同样的方法对每一位的数字枚举递推，到最后一位数都满足条件，就输出得到的这个数列，同时标记
    已经得到过了，之后的深搜不用往下搜了。
//肯定还有更简单的办法

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

int arr[110];
int flag=0;
int f[110]={0};

void doit(int n,int cnt) {
    if(cnt==n+1) {
        flag=1;
        printf("%d",arr[1]);
        for(int i=2;i<=n;i++) {
            printf(" %d",arr[i]);
        }
        printf("\n");
        return ;
    }

    for(int i=1;i<=n;i++) {
        if(!f[i]&&(cnt!=i)&&flag==0) {     //这个数没有排列过&&arr[i]!=i&&还没有得到过正确的数列
            arr[cnt]=i;
            f[i]=1;
            doit(n,cnt+1);      //继续往下搜
            f[i]=0;                     //状态还原
        }
    }
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {    
        int n;
        scanf("%d",&n);
        flag=0;
        doit(n,1);
    }
    return 0;
}

T2 ： https://codeforces.com/problemset/problem/1454/B
题意：给出一列数字，玩家随机选择索引，获胜者的索引有这样的特征————这个数字在数列中只出现了一次，并且这个数字是所有只出现过一次的数字中最小的数字
思路：水水水水题。sort排个序，存储原来的下标，遍历就完事。
//然后猛然发现我这题居然错了一遍！惊了！！！
#include<cstdio>

int main() {
	int n,t;
	int a[200010],tem,a2[200010],s=0;     //直接把输入的数字作为下标
	scanf("%d",&t);
	while(t--) {
		s=0;
		scanf("%d",&n);
		for(int i=0;i<n+1;++i) {
			a[i]=0;
		}
		for(int i=0;i<n;++i) {
			scanf("%d",&tem);
			a[tem]++;     //存储出现的次数
			a2[tem]=i+1;        //存储在原来序列中的下标
		}
		for(int i=1;i<=n;++i) {
			if(a[i]==1) {
				printf("%d\n",a2[i]);
				s=1;
				break;
			}
		}
		if(!s) {
			printf("-1\n");
		}
	}
	return 0;
}
//sort都没用，一个O(n)的算法，用sort就升成O(nlogn)了
然后改我原来的破代码
//这个是wa掉的（用了结构体）交的时候想着这把必过呜呜呜
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

struct Node {
    int index,numb;
    int p;
}arr[MAXN];

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        for(int i=1;i<=MAXN;i++) {     //啊Σ(っ °Д °;)っ做了标记的这两个地方，有等于号会wa掉第三个点
            arr[i].p=0;
        }
        for(int i=1;i<=n;i++) {
            int num;
            scanf("%d",&num);
            arr[num].numb=num;
            arr[num].index=i;
            arr[num].p++;
        }
        int flag=0;
        for(int i=1;i<=MAXN;i++) {	//没有等于号又会t掉第四个点   如果把MAXN换成n就又对了   (っ °Д °;)っ到底是怎么肥四啊啊啊啊
            if(arr[i].p==1) {
                printf("%d\n",arr[i].index);
                flag=1;
                break;
            }
        }
        if(!flag) printf("-1\n");
    }
    return 0;
}
//鸽掉，明天看

T4 ： https://codeforces.com/problemset/problem/1454/C
题意：（题目肯定不是这么描述的，自己提炼一下）给出一组数，选择某个数列中存在的数（必须是全部的位置）把这一列数分割成若干组，问最少可以分出几组（不包含选出的数）
	I can't write Chinese.wuwuwu 啊好了，这其实跟题目表述的选择一个数i，每次去掉全部数列中不包含这个数的子列（连续且完整），问最少的操作数后可以使数列中的数全部相同
思路：根据提炼出来的意思只需要找每个数出现了几次，同时注意特殊情况————某个数连续出现，某个数出现在开头或结尾，这两种情况对最后的统计都有影响
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

using namespace std;

int arr[MAXN];
int p[MAXN];

int min(int a,int b) {
    if(a>b) return b;
    return a;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        memset(arr,0,sizeof(arr));
        memset(p,0,sizeof(p));
        int n;
        scanf("%d",&n);
        int _n=n;
        for(int i=1;i<=_n;i++) {
            scanf("%d",&arr[i]);
            if(i!=1) {
                if(arr[i]==arr[i-1]) {     //去掉连续的，看完我都惊了Σ(っ °Д °;)っ，真的学到了学到了
                    i--;
                    _n--;
                }
            }
        }
        for(int i=1;i<=_n;i++) {
            p[arr[i]]++;
        }
        int ans=999999;
        if(_n==1) {
            printf("0\n");
            continue;
        }
        for(int i=1;i<=n;i++) {
            if(p[i]) {
                ans=min(ans,p[i]);       //某个数出现的次数最少，分割出的子列一定最小
            }
        }
        if(arr[1]==arr[_n]) {
            printf("%d\n",min(ans+1,p[arr[1]]-1));     //在一般位置，子列数是频数+1，在开头和结尾（这是同时出现的特殊位置）是频数-1
        }
        else {
            printf("%d\n",min(ans+1,min(p[arr[1]],p[arr[_n]])));     //只出现开头或结尾，子列数就是频数
        }
    }
    return 0;
}

T4 : https://codeforces.com/problemset/problem/1454/D
//这个题qwq没懂
题意：把一个数按因数从小到大分成一串数，必须满足a[i]和a[i-1]有倍数关系。360——>2，180——>2,2,90 90再分分不出来两个有倍数关系的数了
思路：据说是深搜，但是我没看懂
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

ll arr[MAXN];
ll ans;
ll mid[MAXN];				//mid数组相当于一个中间的过渡量

void dfs(ll sum,ll k,ll la) {    //就是深搜！！！我看懂了！！！   la始终是前面那个数
    if(sum%la==0) {			//如果这个得到的这个较大的因数，是之前的那个较小因数的倍数，就判断得到的这个新的序列长度是不是比之前的长
        mid[k]=sum;
        if(k+1>ans) {
            ans=k+1;
            for(int i=0;i<ans;++i) 		//更长就赋值
                arr[i]=mid[i];
        }       
    }
    else return ;			//如果不是倍数，就需要上一个换上一个因数，退回上一级
    
    for(ll i=la;i*i<=sum;i+=la) {			//每次加la，保证现在这个数的较小因数一定是前面那个数倍数
        if(sum%i==0&&i>1) {
            mid[k]=i;				//就是如果找到了一个因数，就先暂且把这个因数放在过渡量的这个数组里
            dfs(sum/i,k+1,i) ;			//然后接着往后找，较大因数继续进行拆分
        }
    }
    return ;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll n;
        scanf("%lld",&n);
        ans=0;
        dfs(n,0,1);
        printf("%lld\n",ans);
        printf("%lld",arr[0]);
        for(int i=1;i<ans;i++) {
            printf(" %lld",arr[i]);
        }
        printf("\n");
    }
    return 0;
}
//嘤我居然看懂了

T5 ： https://codeforces.com/problemset/problem/1454/E
//直接下一题/(ㄒoㄒ)/~~

T6 ： https://codeforces.com/problemset/problem/1454/F
//不会qwq

Day 3
T1 ： https://codeforces.com/problemset/problem/1461/A
题意：给出两个整数n和k，造一个字符串，这个字符串的长度是n，包含一个长度为k的回文子串；造出来的字符串只能包含字符'a', 'b', 'c'
思路：啊做的时候犹豫了一下下，造一个回文串那岂不是aaaaa/bbbbb/ccccc就完了，结果还真是……
//水题，不用犹豫，敲就是了
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,k;
        scanf("%d%d",&n,&k);
        for(int i=1;i<k;i++) {
            printf("a");      //前面的字符都敲a（b也行）
        }
        for(int i=1;i<=n-k+1;i++) {
            if(i%3==1) printf("a");
            if(i%3==2) printf("b");
            if(i%3==0) printf("c");    //后面的全都abcabcabc循环（这肯定不是回文串啦）
        }
        printf("\n");
    }
    return 0;
}
//题目对回文串没有太大要求，要是要求不能这样造就稍稍麻烦了吧（从前往后到k/2又从后往前，啊也还好）

T2 ： https://codeforces.com/problemset/problem/1461/B
题意：给出n和m分别是矩阵的长和宽，这个矩阵只由'.'和'*'组成，像这样：
.***.   然后要在这个矩阵里找由'*'组成的圣诞树，像这样：           层数可以从1~k，k<=n（矩阵的行数）
*****							   *			*就是一个圣诞树
*****							  ***
*.*.*							 *****
思路：啊看到这题就感觉想到了古早时候做的找细胞的题，呜呜呜不光代码不会打，我连样例都看不懂，结果细看好像也不需要很麻烦的搜索。反正我做的很暴力，╮(╯-╰)╭，这也是没办法的事qwq
      观察发现，这个题它n和m的范围都是500（简直就是暗示要我写暴力），不大，还挺小，够遍历好几遍的了。所以可以先遍历整个矩阵，预处理每个*向左向右分别可以延伸多少个，也就是说最多这个*
      可以做圣诞树的第几层的中心。
      预处理完就可以再遍历一次，选取每一个*作为圣诞树的顶点，题目中甚至给出了第i层*的个数，所以可以从每一个顶点开始直向下走看以这个点为中心位扩展的*是否可以做一层。
      得到最大层数之后，上方的每一层都可以作为一个独立圣诞树最底层，相加得到最终答案。
//思路说的很累赘，代码要更清楚一点
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

char mat[503][503];
int val[505][505];
int ans;
int m,n;

int doit1(int x,int y) {        //进行预处理的部分
    int value=0;
    for(int i=1;y+i<=m&&y-i>=1;i++) {
        if(mat[x][y+i]=='*'&&mat[x][y-i]=='*') {
            value++;
            continue;
        }
        break;
    }
    return value;
}

void doit2(int x,int y) {
    int i=1;
    int _ans=0;
    while(1) {
        if((x+i-1<=n)&&(val[x+i-1][y]>=(i-1))&&(mat[x+i-1][y]=='*')) {   //根据公式计算并判断这一层应该有的*个数
            _ans++;
            i++;
            continue;
        }
        break;
    } 
    for(int i=2;i<=_ans;i++) //_ans是最多层数
        ans+=1;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ans=0;
        scanf("%d%d",&n,&m);
        getchar();
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++)  {
                mat[i][j]=getchar();
                if(mat[i][j]=='*') ans++;
            }
            getchar();
        }

        for(int i=1;i<=n;i++) 
            for(int j=1;j<=m;j++) 
                if(mat[i][j]=='*') val[i][j]=doit1(i,j);

        /*for(int i=1;i<=n;i++) { 
            for(int j=1;j<=m;j++) 
                printf("%d ",val[i][j]);
            printf("\n");
         }*/

        for(int i=1;i<=n;i++) 
            for(int j=1;j<=m;j++) 
                if(mat[i][j]=='*') doit2(i,j);

        printf("%d\n",ans);
    }
    return 0;
}
//我也没想到还怪长的

T3 ： https://codeforces.com/problemset/problem/1461/C
题意：








