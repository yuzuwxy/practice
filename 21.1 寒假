Day1 
//今天份的不想学习
//只做了四道题，剩下一道图论一道线性动态规划之后补

T1 ： https://codeforces.com/problemset/problem/1472/A
题意：给出纸张的长和宽，只有偶数可以继续裁剪。最终能够得到的纸张数是否大于等于指定数目。
思路：很显然最终可以得到的纸张数=裁剪“长” * 裁剪“宽”， 转化为求一个偶数最终能够分为几个奇数————一直除2看能除几次，然后根据（我没有的）数学知识是求2的次幂，怕卡时间写了快速幂
//也不知道说的啥，上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

long long ans;
long long poww;
long long h, w, n;
int t;

long long kpow(long long _poww) {     //变量名实在太丑了点
    long long _ans=1;
    long long b=2;
    if(_poww==0) {
        _ans=1;
        return _ans;
    }
    while(_poww>0) {
        if(_poww&1) 
           _ans=_ans*b;
        b=b*b;
        _poww=_poww>>1;
    }
    return _ans;    //这是快速幂的部分（无情的模板机器
}

long long doit (long long x) {
    poww=0;
    while(!(x&1)) {        //位运算稍微快一点点
        x=x>>1;
        poww++;            //这个是看可以除几次2
    }
    return kpow(poww);
}

int main() {
    scanf("%d", &t) ;
    for(int i = 1; i <= t; i ++) {
        scanf("%lld%lld%lld", &w, &h, &n);
        ans = doit(w) * doit(h);
        if(ans >= n) {
            printf("YES\n");
            continue;
        }
        printf("NO\n");
    }
    return 0;
}
//啊签到题罢辽(但是说不定还有简单做法？

T2 ： https://codeforces.com/problemset/problem/1472/B
题意：给出一串只有1和2的序列，判断是否可以把这个序列分成两个子序列，使两个子序列的所有数之和相对（我也不知道在说啥反正就这个意思
题解：突破点其实在这一串数只有1和2来着（一开始没看见吓死了），稍微要想一下。如果这一串数满足，应该有以下几点特征：
      1.所有数之和不能是奇数，必须是偶数
      //然后思考如果是偶数就一定满足了吗？
      //和是偶数的话，说明1的数量一定是偶数，2的数量可能是奇数可能是偶数。
      //如果2的数量是偶数，那就一定可以，最起码存在两组分别有一半1和一半2；如果2的数量是奇数，设2的数量是y,1的数量是x,满足要求的话也就是2y-x可以对半分，啊那就显然可以。
      //然后注意特殊情况，1的数量是0的话，2的数量是奇数也不行
      2.1的数量为0时，2的数量不能是奇数

//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100010

int t;
int n;
int w[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        scanf("%d",&n);
        int two=0;
        int one=0;
        int ww=0;
        for(int j=1;j<=n;j++) {
            scanf("%d",&w[j]);
            if(w[j]==1) one++;
            if(w[j]==2) two++;
            ww+=w[j];
        }
        if(ww%2==1) {
            printf("NO\n");
            continue;
        }
        if((one==0)&&two%2!=0) {
            printf("NO\n");
            continue;
        }
        printf("YES\n");
    }
    return 0;
}
//稍微还是有点难想吧，题做多了可能敏感度就上来了（？）

T3 ： https://codeforces.com/problemset/problem/1472/C
题意：给出数字序列，下标从1开始，随机选一个下标i开始走，value加上a(i),下一步走到i+a(i),直到走到没法再走。要找出这个下标，使结束时的value最大。
思路：第一反应可能是模拟，一个一个扫过去，但是时间复杂度就很高。所以想到倒推，value[i]=a[i]+value[i+a[i]]
//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

int t=0;
int n=0;
int a[MAXN];
int dp[MAXN]={0};
int ans=0;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            scanf("%d",&a[i]);
        }
        ans=0;
        for(int i=n;i>=1;i--) {
            if(i+a[i]<=n) {
                dp[i]=a[i]+dp[i+a[i]];      //并不是动规，稍微被误导了以下
            }
            else {
                dp[i]=a[i];
            }
            ans=max(ans,dp[i]);
        }
    printf("%d\n",ans);
    }
    return 0;
}
//不太难，偶尔还是要自己想一想感受一下脑子的存在

T4 ： https://vjudge.net/problem/CodeForces-1472/D
题意：奇偶游戏。Alice选偶数加分，Bob选奇数加分，同时两人也可以ban掉对方选的数，当两人最佳发挥时，谁可以最终赢得比赛。
思路：首先思考最佳发挥是怎么发挥法。Alice要总能选到对自己有利的数，每一回合要决定pick还是ban，最终的目的是赢，贪心看，比较pick的数较大还是ban的数较大，就可以确定是ban还是pick；Bob同理。
      所以要对偶数和奇数分别进行排序，然后从大向小遍历。
//还是简单粗暴的上代码写注释

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

int t;
ll totA,totB;
ll jishu[MAXN],oushu[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        int n;
        scanf("%d",&n);
        int ji=1,ou=1;
        for(int j=1;j<=n;j++) {
            ll num;
            scanf("%lld",&num);
            if(num%2==1) {
                jishu[ji]=num;        //奇数和偶数分别放在不同的数组里
                ji++;
            }       
            else {
                oushu[ou]=num;
                ou++;
            }
        }
        sort(jishu,jishu+ji);
        sort(oushu,oushu+ou);
        ji--;
        ou--;   
        totA=0;
        totB=0;
        for(int j=0;j<n;j++) {
            if(j%2==0) {   //Alice的回合
                if((ou==0)&&(ji>0)) {    //如果偶数已经选完，那现在势必是要ban掉奇数
                    ji--;
                    continue;
                }
                if(jishu[ji]<oushu[ou]) {    //如果没有选完，并且pick比ban更有利
                    totA+=oushu[ou];
                    ou--;
                }
                else {
                    if(ji>0) ji--;
                }
                //printf("%lld\n",totA);
            }
            else {
                if((ji==0)&&(ou>0)) {     //Bob同理
                    ou--;
                    continue;
                }
                if(jishu[ji]>oushu[ou]) {
                    totB+=jishu[ji];
                    ji--;
                }
                else {
                    if(ou>0) ou--;
                }
            }
        }
        if(totA>totB) printf("Alice\n");
        if(totA<totB) printf("Bob\n");
        if(totA==totB) printf("Tie\n");
    }   
    return 0;
}

//稍微想一下下，关键在怎么才是最佳发挥

T5 ： https://vjudge.net/problem/CodeForces-1472/E
//这个是后来补的题
题解：就是给出几个矩形的长和宽，然后判断这个矩形是否可以将某个矩形完全覆盖（不包含等号），如果可以就输出被覆盖的矩形的索引，如果没有，就输出-1.
思路：题目中说给出的矩形的“长”和“宽”不一定哪个大，啊啊不知道怎么说。反正根据小学生思维，大的就看作长，小的就看作宽，那其实就无所谓比较的方法了（题目里说的站着或躺着），就可以直接分别比较
    两组数据里较小的和较大的。肯定不能一个一个挨个比啊，直接按照矩形的长把数据排序，只要那么对于第i个矩形是满足条件的矩形，就是1~i-1个矩形里最小的宽比第i个矩形的宽小（啊数学的存在与恒成立
    问题）。然后考虑特殊情况，可能会这样，就是说前面有一个长和宽都比当前这个矩形b小的矩形a，但是现在这个前面有一个长和b一样但是宽比a还要小的矩形c，那么最后找到的可以放在b上矩形是c，但这样是
    错误答案。为了避免这种情况的发生，把相同长的矩形按照宽降序排序。
    以及返回索引应该要存储原来数据的顺序。
#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
#include<math.h>

using namespace std;

struct Node {
    int maxx,minn;
    int num;          //用来存储原来的顺序
    int ans;
}mat[200010];               //涉及到多个关键词排序，用sort的话需要建立结构体

int t;
int n;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int min(int a,int b) {
    if(a<b) return a;
    return b;
}

bool cmp1(Node a,Node b) {
    if(a.maxx!=b.maxx) return a.maxx<b.maxx;
    return a.minn>b.minn;
}

bool cmp2(Node a,Node b) {
    return a.num<b.num;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            int h,w;    
            scanf("%d%d",&h,&w);
            mat[i].maxx=max(h,w);     
            mat[i].minn=min(h,w);      //转换长和宽
            mat[i].num=i;
            mat[i].ans=-1;
        }
        sort(mat+1,mat+1+n,cmp1);
        int _min=1;             //标记当前最小的宽在排好序的数组里的索引
        for(int i=2;i<=n;i++) {
            if(mat[i].minn<mat[_min].minn) {
                _min=i;
            }
            if(mat[i].minn>mat[_min].minn) {
                mat[i].ans=mat[_min].num;
            }
        }
        sort(mat+1,mat+1+n,cmp2);      //按照num排序，也就是回到原来输入的顺序
        printf("%d",mat[1].ans);
        for(int i=2;i<=n;i++) {
            printf(" %d",mat[i].ans);        //不要末尾空格
        }
        printf("\n");
    }
}

//做出来感觉也不咋难（？）

T6 ： https://codeforces.com/problemset/problem/1472/F
//传说中的线性动态规划，不会做，之后补
//嘤我还找规律了结果是错的
//因为不会所以没有题解


T7 ： https://codeforces.com/problemset/problem/1472/G
//显然是道图论题，题目都么的看呜呜呜
//之后有机会补
//图论怎么可能有题解呢（划掉）

Day 2

T1 :  https://codeforces.com/problemset/problem/1454/A
题意：给出数字n，要求对1~n之内的数字进行排列，要求排列得到的数列arr[i]!=i。
思路：题意比较简单，类比之前有道题（啊自己写的深搜递归）是输出1~n之内所有数字所有排列方法，可以用同样的方法对每一位的数字枚举递推，到最后一位数都满足条件，就输出得到的这个数列，同时标记
    已经得到过了，之后的深搜不用往下搜了。
//肯定还有更简单的办法

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

int arr[110];
int flag=0;
int f[110]={0};

void doit(int n,int cnt) {
    if(cnt==n+1) {
        flag=1;
        printf("%d",arr[1]);
        for(int i=2;i<=n;i++) {
            printf(" %d",arr[i]);
        }
        printf("\n");
        return ;
    }

    for(int i=1;i<=n;i++) {
        if(!f[i]&&(cnt!=i)&&flag==0) {     //这个数没有排列过&&arr[i]!=i&&还没有得到过正确的数列
            arr[cnt]=i;
            f[i]=1;
            doit(n,cnt+1);      //继续往下搜
            f[i]=0;                     //状态还原
        }
    }
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {    
        int n;
        scanf("%d",&n);
        flag=0;
        doit(n,1);
    }
    return 0;
}

T2 ： https://codeforces.com/problemset/problem/1454/B
题意：给出一列数字，玩家随机选择索引，获胜者的索引有这样的特征————这个数字在数列中只出现了一次，并且这个数字是所有只出现过一次的数字中最小的数字
思路：水水水水题。sort排个序，存储原来的下标，遍历就完事。
//然后猛然发现我这题居然错了一遍！惊了！！！
#include<cstdio>

int main() {
	int n,t;
	int a[200010],tem,a2[200010],s=0;     //直接把输入的数字作为下标
	scanf("%d",&t);
	while(t--) {
		s=0;
		scanf("%d",&n);
		for(int i=0;i<n+1;++i) {
			a[i]=0;
		}
		for(int i=0;i<n;++i) {
			scanf("%d",&tem);
			a[tem]++;     //存储出现的次数
			a2[tem]=i+1;        //存储在原来序列中的下标
		}
		for(int i=1;i<=n;++i) {
			if(a[i]==1) {
				printf("%d\n",a2[i]);
				s=1;
				break;
			}
		}
		if(!s) {
			printf("-1\n");
		}
	}
	return 0;
}
//sort都没用，一个O(n)的算法，用sort就升成O(nlogn)了
然后改我原来的破代码
//这个是wa掉的（用了结构体）交的时候想着这把必过呜呜呜
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

struct Node {
    int index,numb;
    int p;
}arr[MAXN];

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        for(int i=1;i<=MAXN;i++) {     //啊Σ(っ °Д °;)っ做了标记的这两个地方，有等于号会wa掉第三个点
            arr[i].p=0;
        }
        for(int i=1;i<=n;i++) {
            int num;
            scanf("%d",&num);
            arr[num].numb=num;
            arr[num].index=i;
            arr[num].p++;
        }
        int flag=0;
        for(int i=1;i<=MAXN;i++) {	//没有等于号又会t掉第四个点   如果把MAXN换成n就又对了   (っ °Д °;)っ到底是怎么肥四啊啊啊啊
            if(arr[i].p==1) {
                printf("%d\n",arr[i].index);
                flag=1;
                break;
            }
        }
        if(!flag) printf("-1\n");
    }
    return 0;
}
//鸽掉，明天看

T4 ： https://codeforces.com/problemset/problem/1454/C
题意：（题目肯定不是这么描述的，自己提炼一下）给出一组数，选择某个数列中存在的数（必须是全部的位置）把这一列数分割成若干组，问最少可以分出几组（不包含选出的数）
	I can't write Chinese.wuwuwu 啊好了，这其实跟题目表述的选择一个数i，每次去掉全部数列中不包含这个数的子列（连续且完整），问最少的操作数后可以使数列中的数全部相同
思路：根据提炼出来的意思只需要找每个数出现了几次，同时注意特殊情况————某个数连续出现，某个数出现在开头或结尾，这两种情况对最后的统计都有影响
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

using namespace std;

int arr[MAXN];
int p[MAXN];

int min(int a,int b) {
    if(a>b) return b;
    return a;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        memset(arr,0,sizeof(arr));
        memset(p,0,sizeof(p));
        int n;
        scanf("%d",&n);
        int _n=n;
        for(int i=1;i<=_n;i++) {
            scanf("%d",&arr[i]);
            if(i!=1) {
                if(arr[i]==arr[i-1]) {     //去掉连续的，看完我都惊了Σ(っ °Д °;)っ，真的学到了学到了
                    i--;
                    _n--;
                }
            }
        }
        for(int i=1;i<=_n;i++) {
            p[arr[i]]++;
        }
        int ans=999999;
        if(_n==1) {
            printf("0\n");
            continue;
        }
        for(int i=1;i<=n;i++) {
            if(p[i]) {
                ans=min(ans,p[i]);       //某个数出现的次数最少，分割出的子列一定最小
            }
        }
        if(arr[1]==arr[_n]) {
            printf("%d\n",min(ans+1,p[arr[1]]-1));     //在一般位置，子列数是频数+1，在开头和结尾（这是同时出现的特殊位置）是频数-1
        }
        else {
            printf("%d\n",min(ans+1,min(p[arr[1]],p[arr[_n]])));     //只出现开头或结尾，子列数就是频数
        }
    }
    return 0;
}

T4 : https://codeforces.com/problemset/problem/1454/D
//这个题qwq没懂
题意：把一个数按因数从小到大分成一串数，必须满足a[i]和a[i-1]有倍数关系。360——>2，180——>2,2,90 90再分分不出来两个有倍数关系的数了
思路：据说是深搜，但是我没看懂
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

ll arr[MAXN];
ll ans;
ll mid[MAXN];				//mid数组相当于一个中间的过渡量

void dfs(ll sum,ll k,ll la) {    //就是深搜！！！我看懂了！！！   la始终是前面那个数
    if(sum%la==0) {			//如果这个得到的这个较大的因数，是之前的那个较小因数的倍数，就判断得到的这个新的序列长度是不是比之前的长
        mid[k]=sum;
        if(k+1>ans) {
            ans=k+1;
            for(int i=0;i<ans;++i) 		//更长就赋值
                arr[i]=mid[i];
        }       
    }
    else return ;			//如果不是倍数，就需要上一个换上一个因数，退回上一级
    
    for(ll i=la;i*i<=sum;i+=la) {			//每次加la，保证现在这个数的较小因数一定是前面那个数倍数
        if(sum%i==0&&i>1) {
            mid[k]=i;				//就是如果找到了一个因数，就先暂且把这个因数放在过渡量的这个数组里
            dfs(sum/i,k+1,i) ;			//然后接着往后找，较大因数继续进行拆分
        }
    }
    return ;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll n;
        scanf("%lld",&n);
        ans=0;
        dfs(n,0,1);
        printf("%lld\n",ans);
        printf("%lld",arr[0]);
        for(int i=1;i<ans;i++) {
            printf(" %lld",arr[i]);
        }
        printf("\n");
    }
    return 0;
}
//嘤我居然看懂了

T5 ： https://codeforces.com/problemset/problem/1454/E
//直接下一题/(ㄒoㄒ)/~~

T6 ： https://codeforces.com/problemset/problem/1454/F
//不会qwq

Day 3
T1 ： https://codeforces.com/problemset/problem/1461/A
题意：给出两个整数n和k，造一个字符串，这个字符串的长度是n，包含一个长度为k的回文子串；造出来的字符串只能包含字符'a', 'b', 'c'
思路：啊做的时候犹豫了一下下，造一个回文串那岂不是aaaaa/bbbbb/ccccc就完了，结果还真是……
//水题，不用犹豫，敲就是了
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,k;
        scanf("%d%d",&n,&k);
        for(int i=1;i<k;i++) {
            printf("a");      //前面的字符都敲a（b也行）
        }
        for(int i=1;i<=n-k+1;i++) {
            if(i%3==1) printf("a");
            if(i%3==2) printf("b");
            if(i%3==0) printf("c");    //后面的全都abcabcabc循环（这肯定不是回文串啦）
        }
        printf("\n");
    }
    return 0;
}
//题目对回文串没有太大要求，要是要求不能这样造就稍稍麻烦了吧（从前往后到k/2又从后往前，啊也还好）

T2 ： https://codeforces.com/problemset/problem/1461/B
题意：给出n和m分别是矩阵的长和宽，这个矩阵只由'.'和'*'组成，像这样：
.***.   然后要在这个矩阵里找由'*'组成的圣诞树，像这样：           层数可以从1~k，k<=n（矩阵的行数）
*****							   *			*就是一个圣诞树
*****							  ***
*.*.*							 *****
思路：啊看到这题就感觉想到了古早时候做的找细胞的题，呜呜呜不光代码不会打，我连样例都看不懂，结果细看好像也不需要很麻烦的搜索。反正我做的很暴力，╮(╯-╰)╭，这也是没办法的事qwq
      观察发现，这个题它n和m的范围都是500（简直就是暗示要我写暴力），不大，还挺小，够遍历好几遍的了。所以可以先遍历整个矩阵，预处理每个*向左向右分别可以延伸多少个，也就是说最多这个*
      可以做圣诞树的第几层的中心。
      预处理完就可以再遍历一次，选取每一个*作为圣诞树的顶点，题目中甚至给出了第i层*的个数，所以可以从每一个顶点开始直向下走看以这个点为中心位扩展的*是否可以做一层。
      得到最大层数之后，上方的每一层都可以作为一个独立圣诞树最底层，相加得到最终答案。
//思路说的很累赘，代码要更清楚一点
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

char mat[503][503];
int val[505][505];
int ans;
int m,n;

int doit1(int x,int y) {        //进行预处理的部分
    int value=0;
    for(int i=1;y+i<=m&&y-i>=1;i++) {
        if(mat[x][y+i]=='*'&&mat[x][y-i]=='*') {
            value++;
            continue;
        }
        break;
    }
    return value;
}

void doit2(int x,int y) {
    int i=1;
    int _ans=0;
    while(1) {
        if((x+i-1<=n)&&(val[x+i-1][y]>=(i-1))&&(mat[x+i-1][y]=='*')) {   //根据公式计算并判断这一层应该有的*个数
            _ans++;
            i++;
            continue;
        }
        break;
    } 
    for(int i=2;i<=_ans;i++) //_ans是最多层数
        ans+=1;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ans=0;
        scanf("%d%d",&n,&m);
        getchar();
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++)  {
                mat[i][j]=getchar();
                if(mat[i][j]=='*') ans++;
            }
            getchar();
        }

        for(int i=1;i<=n;i++) 
            for(int j=1;j<=m;j++) 
                if(mat[i][j]=='*') val[i][j]=doit1(i,j);

        /*for(int i=1;i<=n;i++) { 
            for(int j=1;j<=m;j++) 
                printf("%d ",val[i][j]);
            printf("\n");
         }*/

        for(int i=1;i<=n;i++) 
            for(int j=1;j<=m;j++) 
                if(mat[i][j]=='*') doit2(i,j);

        printf("%d\n",ans);
    }
    return 0;
}
//我也没想到还怪长的

T3 ： https://codeforces.com/problemset/problem/1461/C
题意：给定一个长度为n的数组，给出q个操作(r,p), 对[1,r] 区间进行有序排序，排序的概率是p，不变的概率自然就是1−p。问最后数组全部有序的概率是多少。
思路：啊没看懂题啊其实（现在也不咋懂），但是好像是个数学题。
      不懂不懂不懂！！！
      啊啊啊啊糙我看懂了还是要自己看题啊啊啊啊啊
题目的意思我展开说说，就是有一个长度为n的数字序列，我要对它进行m次操作，每一次操作有这样的两个参数，一个针对操作范围，一个针对操作结果，[r,p]，r可以看作每次对数字序列的1~r个数字进行
操作，别管是啥操作，反正我动了一下，然后结果是有q的概率我这几个数变的有序，1-q的概率这几个数的位置不变。然后继续进行下一项操作，对另外几个数再进行类似的操作。
6 5			//给出一个样例，这样长度为6的数字序列进行5个操作
1 3 2 4 5 6		//之前有个疑惑，以为就是给出一个操作之后[1,r]的概率是这样这样，所以迷惑[6,0.7]为啥不直接是答案
4 0.9			//啊就是要操作5次的啊是所以是一个要算的概率的数学题
5 0.3			//是所以说可以跟着这个样例来跑一遍
2 0.4			//诶第一个是有0.9的概率变化前4个，前四个变化对整个数列是否有序是有贡献的。然后是对前5个数操作，这跟上一步对前4个数的操作是有区别的，就是如果上一个操作让前几个数
6 0.7			//变得有序和不变对这一步操作有影响，再往下几步就要分的情况更多，如果按每一步都让让数列变得有序的话，因为要考虑上一个操作完成后的状态。
3 0.5			//所以就正难则反，就假如做完这所有的步骤，我无序，也就是不变，然后最终有序的概率就是1-Q
//然后再继续看，拿这个例子来说的话，因为我最终排好序的序列和初始序列只有前三个不一样，所以说第三个操作，对前两个数进行操作，概率其实是无所谓的，就是我无论前两个数变化还是不变，对整个
//操作，第四个操作我要考虑第三个操作后的状态，而第三个操作完数列还是无序的，那么我第四个操作就不需要对上一步结果分类讨论，因为变不变都是一样的
//啊所以一通乱分析下来，只有初始序列和排好序之后的序列从后往前比第一个不一样的数及其之后的数的操作会影响最终概率
定语十分冗长，代词无比模糊，还是上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 100007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,m;
        int arr[MAXN]={0};
        int _arr[MAXN]={0};
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++) {
            scanf("%d",&arr[i]);
            _arr[i]=arr[i];
        }
        sort(_arr+1,_arr+n+1);  
        int mark=0;
        for(int i=n;i>=1;i--) 
            if(arr[i]!=_arr[i]) {
                mark=i;
                break;
            }
        double ans=1;
        for(int i=1;i<=m;i++) {
            int r;
            double p;
            scanf("%d%lf",&r,&p);
            if(r>=mark) ans*=1.0-p;     //就每次操作后都都不变
        }
        ans=1.0-ans;      //1-无序=有序
        if(mark==0) printf("1.000000\n");
        else 
            printf("%.6lf\n",ans);
    }
    return 0;
}

T4 ： https://codeforces.com/problemset/problem/1461/D
题意：给出一个长度为n的数字序列，然后以mid=（min+max）/2为分界线，把原本的数字序列分成两部分，left=[min,mid],right=(mid,max],再把left和right两个数组按照类似的方式分别分成两部分，每次
      分完各个得到的子序列会得到一个和。然后进行m次询问，每次输入一个数，如果这个数是在操作过程中会得到的和数，就输出YES，否则输出No。
思路：完了这题我现在又不会了。
      第一反应是线段树，就是从小到大排列后把一次分裂得到的两个子序列分别作为一个节点的两个子节点，然后再查询
      //但是因为线段树暂时还没学会呜呜呜没写成
      起码是想到了排序和用upper_bound()或lower_bound()找mid的序号
      反应过来其实不需要做线段树
      就找到了mid的索引，那就可以得到某个子序列的左边界和右边界，前导和就可以直接算出这一段区间的和，那就可以算出可以得到的所有的和了嘛
      //啊暂且算这是思路叭
上代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 100007

using namespace std;

ll arr[MAXN]={0};
ll sum[MAXN]={0};
map<ll,ll> ans;        //之后再说

void doit(int l,int r) {      //处理每一个和是否出现过
    int mid=(arr[l]+arr[r])/2;
    ans[sum[r]-sum[l-1]]=1;
    int pos=upper_bound(arr+l,arr+r+1,mid)-arr;
    if(pos<=r) {
        doit(l,pos-1);
        doit(pos,r);
    }
    return ;
}

void solve() {
    ans.clear();    
    arr[MAXN]={0};
    sum[MAXN]={0};
    int n,q;
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++) {
        scanf("%lld",&arr[i]);
    }
    sort(arr+1,arr+n+1);
    for(int i=1;i<=n;i++) {
        sum[i]=sum[i-1]+arr[i];      //前导和
    }
    doit(1,n);
    ll x;
    while(q--) {
        scanf("%lld",&x);
        if(ans[x]==1) printf("Yes\n");
        else printf("No\n");
    }
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        solve();
    }
    return 0;
}

T5 ： https://codeforces.com/problemset/problem/1461/E
https://vjudge.net/contest/416896#problem/E
我肯定不会啦hhhhh

Day 4  //好几天份的不想学习

T1 : https://codeforces.com/problemset/problem/1451/A
题意：给出一个数，然后对这个数可以让它除一个不是它本身的因数，或者让它减一，输出让这个数变成1的操作数
思路：很好想其实，偶数可以直接除 除2得到的 商，然后减去1，变成1；奇数的话就减去1变成偶数，然后做对偶数做的操作。
      然后就是非常显而易见的特殊情况，这个数本来就是1，这个数本身就是2，这个数减去1后变成的偶数是2
代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        if(n==1) {
            printf("0\n");
            continue;
        }
        if(n==2) {
            printf("1\n");
            continue;
        }
        if(n==3||n%2==0) {
            printf("2\n");
            continue;
        }
        if(n%2==1) {
            printf("3\n");
            continue;
        }
    }
    return 0;
}
//水题实锤

T2 ： https://codeforces.com/problemset/problem/1451/B
题意：给出一串只有0和1 的数字串长度为n，然后是m组测试数据，每一组测试数据有两个数l和r，以这两个数为开头索引和结束索引会得到一个原来数字串的子串，判断是否可以在原来序列里找到一个子序列（
      （索引可以不连续），它的每一个字符在原来序列里对应的索引和测试数据不全相等。
思路：还是要找最低要求，连最低的要求都可以满足，那一定满足题意。那最低要求是什么嘞？中间的字符都取测试数据给的子串，开头和结尾的字符在其他位置找（顺序不能变化），第一个字符往前找，最
      后一个字符往后找。
//不难，好好想想
上代码：
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>
typedef long long ll;
using namespace std;
int main() {
	int t;
    scanf("%d",&t);
	while(t--)
	{
		int n,q;
        scanf("%d%d",&n,&q);
		string s;
        cin>>s;
		while(q--)
		{
			int l,r;
            scanf("%d%d",&l,&r);
			l--;r--;
			int flag=0;
			for(int i=0;i<l;i++)
			    if(s[i]==s[l])  flag=1;
			for(int i=r+1;i<n;i++)
			    if(s[i]==s[r])  flag=1;
			if(flag) cout<<"YES"<<endl;
			else cout<<"NO"<<endl; 
		}
	} 
	return 0;
}

莫名其妙wa掉的代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

int main() {
    int t;  
    scanf("%d",&t);
    while(t--) {
        int n,q;
        char ch[111];
        scanf("%d%d",&n,&q);
        fflush(stdin);
        scanf("%s",ch);
        for(int i=1;i<=q;i++) {
            int ll,r;
            scanf("%d%d",&ll,&r);
            int flag=0;
            for(int j=0;j<ll-1;j++) {
                if(ch[j]==ch[ll-1]) {
                    flag=1;
                    break;
                }
            }
            for(int j=r;j<n;j++) {
                if(ch[j]==ch[r-1]) {
                    flag=1;
                    break;
                }
            }
            if(flag) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}

莫名其妙Re的代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

int main() {
    int t;  
    scanf("%d",&t);
    while(t--) {
        int n,q;
        char ch[111];
        scanf("%d%d",&n,&q);
        //fflush(stdin);
        scanf("%s",ch);
        for(int i=1;i<=q;i++) {
            int le,r;
            scanf("%d%d",&le,&r);
            int flag=0;
            for(int j=0;j<le-1;j++) {
                if(ch[j]==ch[le-1]) {
                    flag=1;
                    break;
                }
            }
            for(int j=r;j<n;j++) {
                if(ch[j]==ch[r-1]) {
                    flag=1;
                    break;
                }
            }
            if(flag) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}
//淦噢我一时竟然不知道该问fflush到底怎么用还是一个地方的bug两次报的错不一样？？
//好叭以后还是老老实实getchar()

T3 ： https://codeforces.com/problemset/problem/1451/C
题意：给出a串和b串，将b串视为标准串，对a串做以下两种操作，判断若干次后是否可以将a串变为b串：
	  1.如果a串有连续k个字符相同，可以把这k个字符的ASCII码值加一变为另一个字符
	  注：k是输入的常数，只可以+1，并且不能循环，也就是'z'+1不是'a'
	  2.交换任意相邻的两个字符
思路：下面是给的一组测试数据，第一个数字是字符串长度第二个字符是k的值
3 3	  很误导我啊真的是这个数据，这个题也真的要好好想的┭┮﹏┭┮
abc   看完第一组：噢好像啥也没看出来，是要把两组相同的字符放在相同索引的位置吗？然后判断不一样的可不可以继续操作，但是没法放啊
bcd				 
4 2	//然后就看第二组哈
abba	//第一反应：啊排序，两个字符串一样的会对应起来然后比较不一样的是不是有连续k个能不能换就好啦
azza
2 1
zz	
aa
6 2
aaabba		//完全不对嘤嘤嘤这个可以是把a放在了一起然后a和d对应了一下，b和c对应了一下，分别加上几。那所以就是把数目一样的放在一起！
ddddcc		//所以给了一个思路是计算每一个字母的数目然后把一样的对应起来看能不能换，然后可能有剩下的，就继续看能换吗（诶试试呗）
那就更麻烦了，因为存在就是好几个字母一样，一个能换可能会导致另一个换不掉（吗），复杂度有点高？
//我的智障思路写出来的奇怪代码，没法往下写根本，因为不知道这样一直找一样的啥时候能结束啊
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include<bits/stdc++.h>

#define ll long long
#define MAXN 1e5+7

int main() {
	int t;
	scanf("%d",&t);
	while(t--) {
		int n,k;
		scanf("%d%d",&n,&k);
		getchar();
		int a[30]={0},b[30]={0};
		for(int i=1;i<=n;i++) {
			int ch=getchar();
			a[ch-'a'+1]++;
		}
		getchar();
		for(int i=1;i<=n;i++) {
			int ch=getchar();
			b[ch-'a'+1]++;
		}
		int flag=0;
		for(int i=1;i<=26;i++) {
			if(a[i]<=b[i]&&a[i]) {     //相同的字母，b串比较多，说明必须有a串别的若干个相连的字母换过来但是不能减只能加
				printf("No\n");
				flag=1;
				break;
			}
			if(a[i]>=b[i]&&b[i]) {   //相同的字母，a串比b串多，说明a串所有的字符都必须转换为其他字母
				a[i]-=b[i];
				b[i]=0;
				if(a[i]%k!=0) {      //必须连续k个相同的字符才能转换，如果不能
					flag=1;
					printf("No\n");
					break;
				}
			}
			//b串里没有这样的字母那就找个数一样的（啊啊啊啊为啥跟刚刚说好的不一样） 
			//我觉得也许应该重新起一个循环？
			for(int i=1;i<=26;i++) {
				if(a[i]) {    //如果还有没变完的，就要找个数一样的（如果没有咋办）
//写到这发现好像写不下去了，因为找完一样的还可能有剩下的，就算是找大于等于的，减完还可能有剩下的，就一片混乱
//还是专注一下这个AC代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 100007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,k;
        scanf("%d%d",&n,&k);
        getchar();
        int a_num[30]={0};
        int b_num[30]={0};
        for(int i=1;i<=n;i++) {
            a_num[getchar()-'a'+1]++;
        }
        getchar();
        for(int i=1;i<=n;i++) {
            b_num[getchar()-'a'+1]++;
        }
        getchar();					//这一部分依旧是统计了各个字母的数量
        int flag=0;
        for(int i=1;i<=26;i++) {				//这个的思路是一个一个挨着换，我最后统计个数就相当于是把相同的字母放在了一起，而且排了序
            if(a_num[i]<b_num[i]) {				//如果我一样的字母目的串比较多，a串就不可能变出这么多这个字母
                printf("No\n");					//所以我最后一定变不出来目的串
                flag=1;							//（这部分我的智障代码也有）
                break;
            }
            if(a_num[i]==b_num[i]) continue;		//如果我同一个字母恰好两个串个数一样，那就不需要做变化了嘛，直接下一个
            if(a_num[i]>b_num[i]) {					//如果我a串这个字母比较多，那我多的字母肯定是要填给其他不够的字母，那我怎么找这个要填的呢
                if(i==26) {							//特判，如果恰好推到最后一个多了，那就说明肯定有一个配不成（但是我咋觉得这种情况不会出现呢）
                    printf("No\n");					//我一直往后推最后前面的都一样了（划掉），会出现的会出现的
                    flag=1;
                    break;
                }
                int dis=a_num[i]-b_num[i];			//干脆就没有找，直接推给了下一个，如果下一个还要多，就相当于是填给了下下一个，反正最后肯定能找到需要的那个
                if(dis%k!=0) {						//如果我多的个数不是k的倍数，那最终填的话总有剩的这个字母，所以肯定也变不成一样的
                    printf("No\n");					//（这一part我的智障代码居然也有）
                    flag=1;
                    break;
                }
                a_num[i+1]+=dis;					//直接推给下一个
            }
        }
        if(!flag) printf("Yes\n");
    }
    return 0;
}
//就好神奇感觉这题做的
//试图在cf上找题解，啊啊啊啊啊我不会
下一题

T4： https://codeforces.com/problemset/problem/1451/D
题意：两个人玩游戏，输出在两人均发挥最佳的情况下赢的人的名字。游戏规则：画一个半径确定的⚪，每个人轮流走一步长度为1，每一步只能向上走或向右走，不能走出这个⚪，谁最先走出这个⚪，
	  谁就输了。
思路：游戏一定会在有限步数内中止。（啊啊啊啊啊啊啊居然会扯到博弈论吗啊啊啊啊完全不懂）
	  啊啊啊啊啊啊气死我了两个人移动的是一颗棋
	  走的最多的时候就是一直拐一直拐，右走一下上走一下然后最后就一定会走到横纵坐标相等的一点上，这时候一定是走了偶数步2n，就判断是否可以继续在走一步
	  //啊啊啊啊学这么年数学真是耻辱啊啊啊啊点（4，4）居然不在半径为5的⚪内！！！！！
我在试着自己写代码了
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>

#define MAXN 1e5+7
#define ll long long

using namespace std;

int main() {   //A是先手
	int t;
	scanf("%d",&t);
	while(t--) {
		ll d,k;
		scanf("%lld%lld",&d,&k);
		ll i;
		for(i=0;i<=d;i+=k) {
			if(i*i+i*i>d*d) break;    //不可能退一步是圆周吧，斜着是整数横着就不可能是整数了吧
		}
		ll end=i-k;
		//printf("%lld\n",end);
		ll maxx=end*end+i*i;      //这个地方如果写进去然后告诉我超int范围不知道为啥写出来就好了
		if(maxx<=d*d) printf("Ashish\n");
		else printf("Utkarsh\n");
	}
	return 0;
}	
//好的这是我的AC代码

T5 ： https://codeforces.com/problemset/problem/1451/E1
//交互题
遭遇滑铁卢
题目的意思大概是一个数字序列长度为n(保证是2的幂次),可以根据数组索引对任意两个数的AND，OR，XOR进行询问，询问次数不超过n+2,求的是这个数字序列。
//英语不好交互题的题目死难看
沙雕思路：一个数跟0按位或得到的还是这个数，所以让第一个数是0，然后依次问每个数跟这个数的或，只需要问n-1次。好憨啊主要是没啥思路。
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int main() {
    ll n;
    scanf("%lld",&n);
    vector<ll> arr(n+1);
    arr[0]=0;
    for(ll i=1;i<n;i++) {
        printf("OR %lld 0\n",i);
        fflush(stdout);
        ll ans;
        scanf("%lld",&ans);
        arr[i]=ans;
    }
    printf("!");
    for(ll i=0;i<n;i++) {
        printf(" %lld",arr[i]);
    }
    printf("\n");
    return 0;
}
大概就是不能自己定数组里的数吧，人家可能有唯一答案┭┮﹏┭┮
翻了题解：
设 x = a + b , y = a + c , z = b + c
因为 a + b = ( a ⊕ b ) + 2 ∗ ( a & b )     //咱也不知道为啥先记着吧
而 ( a ⊕ b ) ⊕ ( a ⊕ c ) = b ⊕ c，所以只需要知道 a & b , a & c , b & c , a ⊕ b , a ⊕ c 这五项就能算出x , y , z 三个数，进而推出 a , b , c  三个数，最后剩下的 n − 3个数，只要一次 ⊕ 就可以解决，因此总共查询的次数为 5 + n − 3 = n + 2次
位运算真的是太优美了（划掉）
淦啊好强，这谁能想到啊
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int main() {
    int n;
    scanf("%d",&n);
    vector<int> res(n+1,0);
    int ab1,ab2,ac1,ac2,bc1,bc2;
    int x,y,z;
    printf("XOR 1 2\n");
    fflush(stdout);
    scanf("%d",&ab1);

    printf("AND 1 2\n");    
    fflush(stdout);
    scanf("%d",&ab2);

    printf("XOR 1 3\n");
    fflush(stdout);
    scanf("%d",&ac1);

    printf("AND 1 3\n");
    fflush(stdout);
    scanf("%d",&ac2);

    bc1=ab1^ac1;

    printf("AND 2 3\n");
    fflush(stdout);
    scanf("%d",&bc2);

    x=ab1+2*ab2;
    y=ac1+2*ac2;
    z=bc1+2*bc2;

    res[1]=(x+y-z)/2;
    res[2]=(x+z-y)/2;
    res[3]=(y+z-x)/2;

    int p;
    for(int i=4;i<=n;i++) {
        printf("XOR 1 %d\n",i);
        fflush(stdout);
        scanf("%d",&p);
        res[i]=p^res[1];          //这里还有一个式子a^b^a=b
    }
    printf("!");
    for(int i=1;i<=n;i++) {
        printf(" %d",res[i]);
    }
    printf("\n");
    fflush(stdout);
    return 0;
}

T6 ： https://codeforces.com/problemset/problem/1451/E2
//两道题一个是简单版一个是比较难的一版呜呜呜
//来了，更难得版本
题意：简单版用了神奇但是我一点都不懂的位运算。困难版相对没有那么数学其实。
      困难版和简单版的区别在于一个询问次数是n+2次一个是n+1次（都不会啊呜呜呜）。
      这题一个需要注意的点是数字的个数跟数字的范围是一致的。
      需要知道的重要的位运算相关的式子有a^b^a=b;a^a=0;if a^b==c^b ,a==c
      很容易想到的一种情况是序列里的数字各不相同，可以数遍数字范围的所有数，但是这样的话要确定用简单版的办法需要n+2次。
      //重点来了，我自己哪能想出来这么厉害的办法，看网上大佬题解会了的：
      按位异或相同的位得到0不同的位得到1，那找到跟第一个数异或（当然是跟第一个数啦完全不会做也可以想到所有的数都要跟第一个数异或eemm参照最开始的沙雕想法）后为1的数，那这个数字跟第一个
      数相差1，这个数跟第一个数按位并，就会得到两个数中的较小数（因为前面的数是一样的最后一个数不同得到0，一定是较小数），那如何确定第一个数是较小数还是较大数呢？
      找到与第一个数按位异或之后结果为2的数，这个数跟第一个数只有转化为二进制后的倒数第二个数不同，最后一位数是相同的，那就让这个数再跟第一个数取并。
      按位与的运算法则是均为1时结果才为1，所以按位与之后的结果可以确定第一个数的最后一位数。
      两次并之后，确定了第一个数，然后再把后面的数的异或结果进行一次异或运算，就可以得到所有的数。
//虽然看了大佬的思路但是自己写了代码，然后wa在了第32个点
//发现最近越来越不爱改bug，一改bug就想干别的，可能是课设后遗症
//第32个点wa而且不给我标为啥就离谱

//我确实离谱
#include<bits/stdc++.h>

using namespace std;

#define ll long long

int main() {
    ll n;
    scanf("%lld",&n);
    vector<int> res(n+1,0);
    //先依次询问跟第一个数的异或（因为连续异或会得到原数）
    vector<ll> Xore(n+1,0);
    int zero=-1;
    for(int i=2;i<=n;i++) {    //数字序列的序号有没有要求我忘记了qwq
        printf("XOR %d 1\n",i);
        fflush(stdout);
        ll ans;
        scanf("%lld",&ans);
        Xore[i]=ans;
        if(ans==0) zero=i;
    }
    //两个相同的数最后异或得到0
    if(zero!=-1) {
        //就是有一个数跟第一个数一样的意思
        printf("AND %d 1\n",zero);
        fflush(stdout); 
        ll ans;
        scanf("%lld",&ans);
        res[1]=ans;
        /*
        for(int i=2;i<=n;i++) {
            res[i]=Xore[i]^res[1];               <改bug：这个要删掉，最后做这个>
        }
        */
    }
    else {
        //没有跟第一个数相同的数，那就要找是不是有后面两个数一样
        //我记得时间卡到2，循环跑了，不是再想办法
        int same1=0,same2=0;
        for(int i=2;i<n;i++) {
            for(int j=i+1;j<=n;j++) {
                if(Xore[i]==Xore[j]) {  //找到了
                    same1=i;
                    same2=j;
                }
            }
        }
        if(same1&&same2) {  //找到了
            printf("AND %d %d\n",same1,same2);
            fflush(stdout);
            ll ans;
            scanf("%lld",&ans);
            /*
            res[same1]=ans;
            res[same2]=ans;             <改bug：这两句删掉，因为最后要对所有的数再跟第一个进行一次异或，所以除了第一个数后面都应该是第一次异或的结果，不能填原数,同理下一句也改了>
            */
            //res[1]=Xore[same1]^res[same1];
            res[1]=Xore[same1]^ans;
        }
        //也可能每个数都不一样，然后根据大佬的思路，找的是跟第一个数异或得到1的数（这个数与第一个数除了最后一位其他都一样）和异或的得到2的数（这个数跟第一个数除了倒数的第二位都一样）
        //那这两个数分别跟第一个数并得到的数就可以知道前面一样的数、确定不一样的数
        else {
            int temp1=0,temp2=0;
            for(int i=2;i<=n;i++) {
                if(Xore[i]==1) {
                    temp1=i;
                    break;
                }
            }
            //一定会有这个数的，因为数的范围和数的个数刚好是一样的
            for(int i=2;i<=n;i++) 
                if(Xore[i]==2) {
                    temp2=i;
                    break;
                }
            ll ans1;;
            printf("AND %d 1\n",temp1);  
            fflush(stdout);
            scanf("%lld",&ans1);    //这个数只有最后一个数不确定，异或为2的数只有倒数第二个数不一样，所以可以通过异或为2的数跟第一个数的并确定倒数第一个数。
            //确定了倒数第一个数，并之后的数就可以是第一个数）
            ll ans2;
            printf("AND %d 1\n",temp2);
            fflush(stdout);
            scanf("%lld",&ans2);
            /*
            if((ans2&1LL)!=(ans1&1LL)) {//最后一位数需要修改
                if(((ans2&1LL)==0)&&((ans1&1LL)==1)) {
                    res[1]=ans1-1;
                }
                if(((ans2&1)==1)&&((ans1&1)==0)) {           <改bug：这一段应该是没问题，但是第二遍看的时候改的稍微不那么丑陋一点>
                    res[1]=ans1+1;
                }
            }
            */
            //因为ans1一定是较小数，最后一位一定是0，所以只需要判断ans2最后一位是不是1
            if(ans2%2==1) {//最后一位数需要修改
                res[1]=ans1+1;
            }
            else res[1]=ans1;
        }
    }
    for(int i=2;i<=n;i++)
        res[i]=Xore[i]^res[1];
    printf("!");
    for(int i=1;i<=n;i++) {
        printf(" %d",res[i]);
    }
    printf("\n");
    return 0;
}    
//嘻嘻夸一夸自己

Day 5
T1: https://codeforces.com/problemset/problem/1452/A
题意：在一个无限大的坐标系中，从原点出发到达目标点，在一次操作中可以使点向上下左右移动或者不动，求到达目标点的最少操作数。并且注意不能连续进行同一个操作
思路：啊这个还想了好一会来着。不能连续走几步所以要到达目标点就得一直拐着走，向着目标冲的话，就右一下上一下，最后可以走到和目标点一行的（k，k）点上，然后判断接下来怎么走。
	  横着挪过去就是|_|一|这么走，然后发现相邻的两个点之间是不需要走三步的，走一步顿一下再走一步只需要两步就可以完成
	  所以可以直接找出规律列式子（就不列啦，好几种走法和理解的方法有点点乱），上代码啦
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int x,y;
        scanf("%d%d",&x,&y);
        if((abs(y-x))<=1) printf("%d\n",x+y);  //这两步就是找到的规律
        else printf("%d\n",2*(max(x,y))-1);
    }
    return 0;
}
//水题石锤

T2 ： https://codeforces.com/problemset/problem/1452/B
题意：若干个箱子里面放有小方块，希望任选一个箱子把里面的小方块往其他箱子移动，怎么移动不用管，但是希望做到最后可以每个箱子里的小方块一样多。初始状态不一定是满足这个条件的，需要添加
	  小方块（怎么添加也不用管）达成这样的条件，问最少要添多少个
思路：啊那就来叨逼叨比我的心路历程
	  Round 1 
	  极端情况就是用选到最小的把全部都凑成最大的，那凑完之后的总数就是（n-1)*max，只需要算这个值和sum的差。然后对着样例试了试，发现有可能最小的凑过去（n-1)*max比sum要小。
	  ┭┮﹏┭┮5
	  Round 2
	  然后对着样例算如果出现了这种情况该怎么办，不知道为啥但是凑出来发现是sum-(n-1)*max，诶那就直接算绝对值。不会造数据就只好仿造了几个差不多的然后‘居然算下是对的？！然后就加了abs，
	  毫不惊讶，wa掉了。
	  ┭┮﹏┭┮
	  Round 3
	  开动我的小脑筋了，假如，我就只考虑极端情况，我挑中了最小的，然后要把最小的箱子里的小方块摊到其他的里面去，摊法很多，往哪个加都可以，好叭好像加法不一样得到的结果会有点不一样叭，
	  但是我不知道(●ˇ∀ˇ●)，所以瞎猜让每个数分1轮着来，啊然后找出最大值算（n-1）*max'，计算差值。啊一听就很扯啊哈哈哈哈毫不意外的wa掉了
	  ┭┮﹏┭┮
	  Round 4
	  然后就开始借鉴大佬的思路啦，（n-1）*max既然小，那一定是max出了问题，那就把max加上直到大了为止。说好的是会t为啥我一交就wa了呜呜呜
	  ┭┮﹏┭┮
	  Round 5
	  然后用了二分，对max的值从最大值开始二分分到合适。
	  终于该对了吧！！！
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll a[MAXN]={0};
        int n;
        scanf("%d",&n);
        ll sum=0;
        ll maxx=-1;
        for(int i=1;i<=n;i++) {
            scanf("%lld",&a[i]);
            sum+=a[i];
            maxx=max(maxx,a[i]);
        }
        ll l=maxx,r=2e9;
        while(l<r) {
            ll mid =(l+r)>>1;
            if((mid*(n-1)>=sum)) r=mid;
            else l=mid+1;
        }
        printf("%lld\n",(n-1)*l-sum);
    }
    return 0;
}
//啊Tag没打二分交了八百遍都不对，诶也许binary search是二分的意思？
//我是five实锤

T3：https://codeforces.com/contest/1452/problem/C
题意：[和]匹配，（和）匹配，没啥好说的
思路：这题我会！！！先进先出！！！维护一个队列！！！
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    getchar();
    while(t--) {
        char s[MAXN];
        scanf("%s",s);
        int tail1=0,head1=0;      //head指向了开头的前一个位置，tail指向末尾位置
        int tail2=0,head2=0;
        int ans=0;
        int len=strlen(s);
        for(int i=0;i<len;i++) {
            char ch=s[i];
            if(head1<tail1&&ch==')') {
                head1++;                  //好抽象的队列，数组都没用嘻嘻嘻夸夸我自己
                ans++;
            }
            if(ch=='(') tail1++;
            if(head2<tail2&&ch==']') {
                head2++;
                ans++;
            }
            if(ch=='[') tail2++;
        }
        printf("%d\n",ans);
    }
    return 0;
}
//既然做的非常顺畅就没啥好说的
//完了然后后面的三道题我都没做
T4：https://codeforces.com/problemset/problem/1452/D
T5：https://codeforces.com/problemset/problem/1452/E
T6：https://codeforces.com/problemset/problem/1452/F

Day 6

T1：https://codeforces.com/problemset/problem/1447/A
题意：n个包裹里第i个包裹装了i颗糖，对这些包裹进行m步操作，第j步选择任意一个包裹，将除了选中的包裹之外的其他包裹里的糖果+j，使最终所有包裹里的糖果数目相等.
	  要求输出操作的步数和每步操作选中的包裹序号。
思路：稍微想了一下还是。看起来好像很复杂，但其实“将除了选中包裹之外的其他包裹里的糖果数目+j”和将选中包裹中的糖果数目减j的效果其实是一样的。所以第j步选中第j+1个包裹，将这个包裹里的糖果
	  数目-j，最后就会得到全部都是1的包裹。
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        printf("%d\n",n-1);
        printf("2 ");
        for(int i=3;i<=n;i++) {
            printf(" %d",i);
        }
        printf("\n");
    }
    return 0;
}

T2：https://codeforces.com/problemset/problem/1447/B
题意：一个n行m列的数字矩阵，里面有正数有负数，对这个矩阵可以进行两种操作：交换相邻两个数字的位置，将相邻的两个数字同时乘-1.在若干次操作后，所以数字的和最大可以是多少？
思路：既然可以相互交换，那么数字的位置就无所谓了，只需要考虑值和个数。相邻的两个数字同时×-1，说明相邻的两个负数可以变为正数，既然要最后的和尽量大，那所有一对一对的负数就得变过来，正数
	  不需要操作。所以只需要判断负数的个数，如果是偶数就说明可以全部凑到一起一个一个变成正数，然后对所有数字求和；如果是奇数，就把偶数个的负数变正，然后剩下的那个负数要在所有的数里
	  绝对值最小
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,m;
        scanf("%d%d",&n,&m);
        int sum=0;
        int neg=0;
        int minn=999;
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++) {
                int num;
                scanf("%d",&num);
                if(num<=0) neg++;
                sum+=abs(num);
                minn=min(minn,abs(num));
            }
        }
        if(neg&1) printf("%d\n",sum-2*minn);
        else printf("%d\n",sum);
    }
    return 0;
}
//今日份的不想学习先告一段落叭qwq
//早睡早起身体好

T3：https://codeforces.com/problemset/problem/1447/C
题意：背包的最大承重量是W，将n件物品中的几件装入背包中，给出n件物品分别的重量，要求装入的物品总重W/2<=w<=W,如果可以达成这个条件，输出装入物品的总数和序号，否则输出“-1”
思路：啊肯定是要排序的嘛。然后就加，如果加到一半发现过了W/2，那条件就满足了；如果加到一半不够W/2，但是再加下一个就超了W，那一个一个加就不能满足条件，但是可以判断会不会有一个物品的重
	  量在范围内，那就只放一个就可以满足；还有可能全部加上都满足不了条件。
//交了八百遍过不了的题，我再试最后一把
//第一版代码
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>

#define MAXN (int)2e5+7
#define ll long long

using namespace std;

struct Node {
	ll wei;
	ll num;
}items[MAXN];

bool cmp(Node a,Node b) {
	if(a.wei==b.wei) return a.num<b.num;
	return a.wei<b.wei;
}

int main() {   
	int t;
	scanf("%d",&t);
	while(t--) {
		ll n,w;
		ll sum=0;
		scanf("%lld%lld",&n,&w);
		for(int i=1;i<=n;i++) {
			scanf("%lld",&items[i].wei);
			items[i].num=i;
		}
		sort(items+1,items+n+1,cmp);
		if(items[1].wei>w) {
			printf("-1\n");
			continue;
		}
		int i;
		ll temp=0;
		for(i=1;i<=n;i++) {
			if(sum<w/2) {
				sum+=items[i].wei;
				temp++;
			}
		}
		if(temp==n&&sum<(w/2)) {
			printf("-1\n");
			continue;
		}
		if(sum<=w&&sum>=w/2) {
			printf("%lld\n",temp);
			printf("%lld",items[1].num);
			for(int i=2;i<=temp;i++) {
				printf(" %lld",items[i].num);
			}
			printf("\n");
		}
		else {
			printf("1\n");
			for(int i=1;i<=n;i++) 
				if(items[i].wei>=w/2&&items[i].wei<=w) {
					printf("%lld\n",items[i].num);
					break;
				}
		}
	}
	return 0;
}	
居然第二个点就WA了！！！！！！！！
不懂为啥会wa，明明没啥毛病呜呜呜
//造出来数据改了一点居然还WA在第二个点！！！啊啊啊啊气死我了
//发现w/2在w是奇数和偶数的时候存在一点歧义
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>

#define MAXN (int)2e5+7
#define ll long long

using namespace std;

struct Node {
	ll wei;
	ll num;
}items[MAXN];

bool cmp(Node a,Node b) {
	if(a.wei==b.wei) return a.num<b.num;
	return a.wei<b.wei;
}

int main() {   
	int t;
	scanf("%d",&t);
	while(t--) {
		ll n,w;
		ll sum=0;
		scanf("%lld%lld",&n,&w);
		for(int i=1;i<=n;i++) {
			scanf("%lld",&items[i].wei);
			items[i].num=i;
		}
		sort(items+1,items+n+1,cmp);
		if(items[1].wei>w) {
			printf("-1\n");
			continue;
		}
		int i;
		ll temp=0;
		ll half=((w%2==0)?(w/2):((w+1)/2));    //奇数的话会有小数点<=比较好，但是偶数<就可以
		for(i=1;i<=n;i++) {
			if(sum<half) {
				sum+=items[i].wei;
				temp++;
			}
		}
		if(temp==n&&sum<half) {
			printf("-1\n");
			continue;
		}
		if(sum<=w&&sum>=half) {
			printf("%lld\n",temp);
			printf("%lld",items[1].num);
			for(int i=2;i<=temp;i++) {
				printf(" %lld",items[i].num);
			}
			printf("\n");
		}
		else {
			printf("1\n");
			for(int i=1;i<=n;i++) 
				if(items[i].wei>=half&&items[i].wei<=w) {
					printf("%lld\n",items[i].num);
					break;
				}
		}
	}
	return 0;
}
//道理我都懂但是为啥会wa啊啊啊啊啊啊啊啊啊
//大佬的AC代码#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

int t;
ll n,W;
ll w[200007];
struct node{
	ll id;
	ll w;
}ww[200007];

bool cmp(node x,node y)
{
	return x.w < y.w;
}

bool cmp1(node x,node y)
{
	return x.id < y.id;
}

int main()
{
	scanf("%d",&t);
	while(t--)
	{
		ll sum = 0;
		scanf("%lld%lld",&n,&W);
		ll half = W / 2;
		if(W % 2 != 0) half++;
		ll flag = 0;
		ll minn = 1000000007;
		ll psb = 0;
		for(int i=1;i<=n;i++)
		{
			scanf("%lld",&w[i]);
			minn = min(minn, w[i]);
			if(w[i] >= half && w[i] <= W) psb = i;
			sum += w[i];
		}
		if(minn > W)
		{
			printf("-1\n");
			continue;
		}
		if(psb > 0)
		{
			printf("1\n%lld\n",psb);
			continue;
		}
		if(sum >= half && sum <= W)
		{
			printf("%lld\n",n);
			for(int i=1;i<=n;i++) printf("%d ",i);
			printf("\n");
		}
		else if(sum < half) printf("-1\n");
		else
		{
			for(int i=1;i<=n;i++)
			{
				ww[i].id = i;
				ww[i].w = w[i];
			}
			sort(ww + 1, ww + 1 + n, cmp);
			ll cnt = 0;
			ll tmp = 0;
			while(tmp < half)
				tmp += ww[++cnt].w;
			if(tmp > W)
			{
				printf("-1\n");
			}
			else
			{
				sort(ww + 1, ww + 1 + cnt, cmp1);
				printf("%lld\n",cnt);
				for(int i=1;i<=cnt;i++)
					printf("%lld ",ww[i].id);
				printf("\n");
			}
		}
	}
	return 0;
}
//明明跟我的区别也不大啊就是位置换了下为啥啊呜呜呜
T4：https://codeforces.com/problemset/problem/1447/D
题意：对于两个字符串A和B，C和D分别是他们的子串，定义一种运算S(C,D)=LCS(C,D)-|C|-|D|，LCS是最长公共子序列，求给出的字符串A，B可以得到的最大的S
	  注：子串是在原串中连续的一段，子序列可以不连续
思路：啊好显然的DP啊，一看就是我不咋会的题目.
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 5007

using namespace std;

char a[MAXN];
char b[MAXN];
int f[MAXN][MAXN]={0};

int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    scanf("%s",a+1);
    scanf("%s",b+1);
    int ans=0;   
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {    //f[i][j]存放的是A串以第i个字符结尾，B串以第j个字符结尾时的S值
            if(a[i]==b[j])        //如果这个字符是一样的，那加上这个字符子串长度+1，子序列长度+1，S+2
                f[i][j]=max(f[i][j],f[i-1][j-1]+2);    //比较加和在这停哪个大
            else 
                f[i][j]=max(f[i][j],max(f[i-1][j]-1,f[i][j-1]-1));        //如果不一样就要比较是谁往后走一个
            ans=max(f[i][j],ans);    //比较到哪会得到最大的S值
        }
    }
    printf("%d\n",ans);
    return 0;
}
//好叭其实有点不懂为啥要和f[i][j]本身比，初始不都是0嘛qwq
后面两题没做，之后补题
T5：https://codeforces.com/problemset/problem/1447/E
T6：https://codeforces.com/problemset/problem/1447/F

Day 7
T1：https://codeforces.com/problemset/problem/1389/A
题意：给出一段区间的左右边界，要求找出本身在该范围内且最小公倍数也在该范围内的两个数。
思路：同样是考虑极限情况，两个数最小公倍数最小时是其中一个数本身，较大数最小是较小数的两倍，较小数最小是左边界。也就是说需要判断的是左边界的二倍是否处于该区间内。
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll le,ri;
        scanf("%lld%lld",&le,&ri);
        if((le<<1)>ri) printf("-1 -1\n");
        else printf("%lld %lld\n",le,le<<1);
    }
    return 0;
}

T2： https://codeforces.com/problemset/problem/1389/B
题意：给出长度为n的数字序列，初始i=1，每一步操作可以选择向右走或者向左走（如果可以的话），且不能连续向左走；每一步操作i变化1，value值加上走到的i对应的数组值。k步之后最多可以拿到多少
	  value。给出可以走的步数和最多可以向左走的步数（可以向左走小于这个数的任意步）。
思路：会想不会写就是我了。如果选择要向左走，那一定是选择相邻两个和最大反复横跳，同时要考虑在这两个反复横跳和往后走哪个更值得。算是伪dp叭
//尝试自己再撸一遍代码
//不太算是自己撸的把原来代码放过来辽毕竟有注释()
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,k,z;
        scanf("%d%d%d",&n,&k,&z);
        int arr[MAXN]={0};
        for(int i=1;i<=n;i++) {
            scanf("%d",&arr[i]);
        }
        int sum=0;
        int maxx=0;
        int ans=0;
        k++;    //因为k是步数，加一才是最终可以到达的下标
        for(int i=1;i<=k;i++) {        //最多可以到达第k+1个数，循环上限用k不用n
            sum+=arr[i];
            if(i<n) maxx=max(maxx,arr[i]+arr[i+1]);
            ans=max(ans,min((k-i)/2,z)*maxx+sum);    //k加了1，i（现在走的第几步）也加了1
        }
        printf("%d\n",ans);
    }
    return 0;
}

T3：https://codeforces.com/problemset/problem/1389/C
T4：https://codeforces.com/problemset/problem/1389/D
T5: https://codeforces.com/problemset/problem/1389/E
震惊后面三道题居然都没做

Day8
T1:https://codeforces.com/problemset/problem/1392/A
题意：长度为n的数字序列，可以任意选中两个数字用之和替代，最终要使序列中的全部都一样，输出最后相同数字的个数。
思路：忘了。
	  噢记起来了，因为题目要的是最少个数，可以这么想，从最大的数字开始，一直跟旁边的某个数字合并，就不可能遇到相同的值，最后一定会合成一个数。除非所有的数字都相等。
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define MAXN 200007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        int flag=1;
        int arr[MAXN]={0};
        for(int i=1;i<=n;i++) {
            scanf("%d",&arr[i]);
            if(i!=1) {
                if(arr[i]!=arr[i-1]) {
                    flag=0;
                }
            }
        }
        if(flag==1) printf("%d\n",n);
        else printf("1\n");
    }
    return 0;
}
T2:https://codeforces.com/problemset/problem/1392/B
题意：对长度为n的数字序列进行这样的操作：找出目前数列的最大值记为d，将序列的每个数变为d-ai。给出操作次数，输出最终得到的数字序列。
思路：仔细一想就知道最后数列会变成一样的。奇数次是一种偶数次是另一种
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        ll arr[MAXN]={0};
        ll k;
        scanf("%d%lld",&n,&k);
        ll maxx1=-1e10,maxx2=-1e10;
        for(int i=1;i<=n;i++) {
            scanf("%lld",&arr[i]);
            maxx1=max(maxx1,arr[i]);
        }
        //int arr1[MAXN]={0};
        for(int i=1;i<=n;i++) {
            arr[i]=maxx1-arr[i];
            maxx2=max(arr[i],maxx2);
        }
        if(k&1) {
            printf("%lld",arr[1]);
            for(int i=2;i<=n;i++) {
                printf(" %lld",arr[i]);
            }
        }
        else {
            printf("%lld",maxx2-arr[1]);
            for(int i=2;i<=n;i++) {
                printf(" %lld",maxx2-arr[i]);
            }
        }
        printf("\n");
    }
    return 0;
}
//水水水题
T3:https://codeforces.com/problemset/problem/1392/C
题意：一串长度为n的数字序列，每次可以选中一段区间让这一段区间的每一个数字+1，最终使这段，数字序列非降，求最少操作次数。
思路：非常容易多想噢搜索回溯什么的然后情况讨论不清楚
	  如果遇到了当前值小于前一个值，ans加上之差。因为后面这一段不管多远不管截至到哪一定要至少加上这个值，中间有加了不够的说明中间还有当前值小于前一个值继续加上差值。
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        ll arr[MAXN]={0};
        ll ans=0;
        for(int i=1;i<=n;i++) {
            scanf("%lld",&arr[i]);
            if(arr[i]<arr[i-1]) ans+=arr[i-1]-arr[i];
        }
        printf("%lld\n",ans);
    }
    return 0;
}
//看代码就会哇塞原来是这样(o゜▽゜)o☆

T4:https://codeforces.com/problemset/problem/1392/D
T5:https://codeforces.com/problemset/problem/1392/E
T6:https://codeforces.com/problemset/problem/1392/F
//啊哦后面三题没做。

Day9
T1：https://codeforces.com/problemset/problem/1466/A
题目：只看题目不知道是我英语不太好还是咋没看太懂，完全不知道是要干个啥，看完后面注释才明白，简练一下就是给出一串数字分别表示线段端点在x轴上的坐标，计算组成了多少个不同长度的线段。
思路：数据真的非常非常小100 50 50，不能更暴力了
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define MAXN 200007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        int arr[100]={0};
        int cha[100]={0};
        for(int i=1;i<=n;i++) {
            scanf("%d",&arr[i]);
        }
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=n;j++) {
                cha[abs(arr[i]-arr[j])]++;
            }
        }
        int ans=0;
        for(int i=1;i<=50;i++) {
            if(cha[i]) ans++;
        }
        printf("%d\n",ans);
    }
    return 0;
}

T2: https://codeforces.com/problemset/problem/1466/B
题目：可能又是一道没咋看懂题目的题？好像题目的意思是每个数只能加1次吧……然后判断这一串数字里不同数字的个数
思路：就模拟叭，遍历然后计算出现的个数，如果大于1就可以给一个数+1，然后再把下一个数出现的次数+1.
//勉强算一道水题叭
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        int notes[MAXN]={0};
        for(int i=1;i<=n;i++) {
            int note;
            scanf("%d",&note);
            notes[note]++;
        }
        int ans=0;
        for(int i=1;i<=2*n+1;i++) {
            if(notes[i]) ans++;
            if(notes[i]>1) notes[i+1]++;
        }
        printf("%d\n",ans);
    }
    return 0;
}
T3: https://codeforces.com/problemset/problem/1466/C
题目：给出一串字符，其可能含有回文子串，求改动的最少字符数使这一串字符不出现回文子串。
思路：
//假公济私，纳博科夫《微暗的火》，唐建清《独抒己见》
一个回文串关键的部分就是aba，或者aa这个样子的，改哪个不太能捋顺也不知道一不一样，所以跟了样例看，样例有一个bbbbbbb一共七个b，给的答案是4，分别用两种方法改了改，发现改前面那个很明显
不太行，会一直遇到两个一样的然后改前面那个就改了个遍，改后面那个就好了，同理第一种情况也改了后面那个。
//有大佬还考虑了aaa这样的情况，直接改掉后边两个，和先考虑aa再考虑aba是一样的。
//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 100007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        char s[MAXN];
        int f[MAXN]={0};
        scanf("%s",s);
        int len=strlen(s);
        int ans=0;
        for(int i=1;i<len;i++){
            if(s[i]==s[i-1]&&f[i-1]==0) {
                ans++;
                f[i]=1;
            }
            if(i>=2&&s[i]==s[i-2]&&f[i-2]==0) {
                ans++;
                f[i]=1;
            }
        }
        printf("%d\n",ans);
    }
    return 0;
}
//想的时候还挺顺当，没想到打出来居然在怎么标记有没有改过卡了好一会

T4: https://codeforces.com/problemset/problem/1466/D
T5: https://codeforces.com/problemset/problem/1466/E
T6: https://codeforces.com/problemset/problem/1466/F
//真是惭愧，又是我没做完的DEF
//一定补一定补

Day 10
//后边的题难度直线上升，就不会呜呜呜
//只做了两个题呜呜呜
T1：https://codeforces.com/problemset/problem/1474/A
题目：两串只含有0和1的数（包含前导0）a，b，不进位相加得到一串包含0，1，2的数（不含前导0），然后把得到结果连续相同的几个字符并成1个记位一个十进制数。给出a，求一个b使最后得到数字最大。
思路：
//又来谋私，纪德《人间食粮》好像听过
啊肯定要遍历，尽量都能加到最大，而且不和前面那个一样，那就判断a[i]+1是否等于sum[i-1]
之前的那个思路忘记了略麻烦，而且wa掉了
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define MAXN 100007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        int num[MAXN]={0};
        getchar();
        for(int i=1;i<=n;i++) {
                num[i]=getchar()-'0';
        }
        int _num[MAXN]={0};
        _num[1]=1;
        printf("%d",_num[1]);    //第一位一定要最大
        for(int i=2;i<=n;i++) {
            int w=1+num[i];
            if(w==num[i-1]+_num[i-1]) _num[i]=0;    //如果第i位的和（最大当然是+1)和前一位相同那就不需要再加了不然会消掉
            else _num[i]=1;
            printf("%d",_num[i]);
        }
        printf("\n");
    }
    return 0;
}
T2：https://codeforces.com/problemset/problem/1474/B
题目：求一个整数它至少有4个因数，并且任意两个因数之间的差不小于d
思路：看出来了，数学题呜呜呜。
	  就写了好多好多数然后发现两个质数的乘积是一定满足的，所以就转化成了找质数
	  //看了网上的题解一下就说是要是质数我也不知为啥qwq
#include<bits/stdc++.h>
#define LL long long
using namespace std;
bool prime(int digit)      //判断这个数是不是质数
{
	if(digit==2||digit==3) return true;
	else if(digit<=1||digit%2==0) return false;
	else{
		for(int i=3;i*i<=digit;i+=2){
			if(digit%i==0) return false;
		}
		return true;
	}
}
int main()
{
	int t;
	cin>>t;
	while(t--){
		int a,ans=1,f=0;
		cin>>a;
		for(int i=a+1;;i++){     //差是a，这个质数最小也要在a+1找起，因为一定有一个因数是1
			if(prime(i)&&f==0){
				ans*=i;
				f++;
			}								//如果找着了一个
			if(prime(i)&&f==1&&i-ans>=a){			//得去找找第二个
				ans*=i;
				f++;
			}
			if(f==2) break;
		}
		cout<<ans<<endl;
	}
	return 0;
}

T3: https://codeforces.com/problemset/problem/1474/C
T4: https://codeforces.com/problemset/problem/1474/D
T3: https://codeforces.com/problemset/problem/1474/A
//惭愧又没做会

Day11
//我今天可出息了做了三道题
T1:https://codeforces.com/problemset/problem/872/A
题目：给出两组长度为n的数字序列（1~9），在两个数组中分别任意取一个数字可以组成一个两位数（顺序任意），如果这两个数字一样就只取一个成为一位数。找出可以组成的最小数。
思路：肯定是一位数更小所以算每个数字出现的次数如果两次就直接输出这个数（最小的），没有一样的就把两个数组排序然后选最小的两个。
//？？？代码看的我一头雾水
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define MAXN 100007

using namespace std;

int main() {
    int n,m;
    scanf("%d%d",&n,&m);
    int a[15]={0};
    int b[15]={0};
    for(int i=1;i<=n;i++) {
        scanf("%d",&a[i]);
    }
    for(int i=1;i<=m;i++) {
        scanf("%d",&b[i]);
    }
    sort(a+1,a+n+1);
    sort(b+1,b+m+1);
    for(int i=1;i<=n;i++) {
        for(int j=1;j<=m;j++) {
            if(a[i]==b[j]) {
                printf("%d\n",a[i]);
                return 0;
            }
        }
    }        
    printf("%d%d\n",min(a[1],b[1]),max(a[1],b[1]));
    return 0;
}
//出了一点点小差错
T2:https://codeforces.com/problemset/problem/872/B
题目：有的数字可以被分成若干个合数的和。求这个数最多可以被分为多少个合数的和。
思路：思维。最小的合数是4，那这个数尽量往大的分最理想就是全部分成4这样的话一定是最多的，但是有的数可能不是4的倍数，有余数就要考虑余数怎么办，4肯定是要保留，余数是1的话，就4+4+1=9是合数，
	  那就得要求至少有3个4，5、9不行。以此类推余数是2，那就把4+2=6，这就要求至少要有两个4，一个四6是不行的；余数是3，那就把3拆成1和2，给3个4摊一摊，所以7、11不行。
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100007
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll n;
        scanf("%lld",&n);
        if(n==1||n==2||n==3||n==5||n==7||n==11) {   //特殊情况考虑
            printf("-1\n");
            continue;
        }
        if(n%4==0) printf("%lld\n",n/4);       //分类讨论
        if(n%4==1) {
            printf("%lld\n",n/4-1);
        }
        if(n%4==2) {
            printf("%lld\n",n/4);
        }
        if(n%4==3) {
            printf("%lld\n",n/4-1);
        }
    }
    return 0;
}

T3:https://codeforces.com/problemset/problem/872/C
题目：把一串数字序列分为k段非空序列，求每段子序列的最小值，找出可以得到的最大的最小值。
思路：还是稍稍想一下，就很容易想到如果k=1，那就直接是全部的最小值；然后k很多的话，就可以直接把整个数列的最大值单独隔出来，那最小值的的最大值就是整个数列的最大值，不可能更大；但是特殊
	  情况就是k=2的话，不一定可以把最大值单独隔离出来，想跑循环但是不会呜呜呜，仔细考虑一下，假设这个隔板放在了中间的某个地方，那就一定会有一半的最小值是整个数列的最小值，另一半的最
	  小值就是最终答案的备用值，然后把隔板往这一边挪，整个数列的最小值不会变化，但是另一半的最小值肯定不会减小，如果比较靠中间的话，那我往这边挪就会把原来应该是最小值的这个数挪到另一半
	  去，最次就是我这一半的最小值就在端点那就一直挪动挪到只剩一个数找到最终答案，反正最终肯定会挪到这个地步就是一半的最小值是整个数列的最小值，另一半的最小值是端点处的值。
	  //我也不知道麻麻烦烦说了啥，还真的是有高三改错那味了，反正我自己捋顺了
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 1000007
#define ll long long

using namespace std;

int main() {
    int n,k;
    scanf("%d%d",&n,&k);
    ll arr[MAXN]={0};
    ll maxx=-0x7fffffff;
    ll minn=0x7fffffff;
    for(int i=1;i<=n;i++) {
        scanf("%lld",&arr[i]);
        maxx=max(maxx,arr[i]);
        minn=min(minn,arr[i]);
    }
    if(k==1) printf("%lld\n",minn);
    if(k>=3) printf("%lld\n",maxx);
    if(k==2) printf("%lld\n",max(arr[1],arr[n]));
    return 0;
}

T4:https://codeforces.com/problemset/problem/872/D
T5:https://codeforces.com/problemset/problem/872/E
//CF上的题真的是好重思维啊俩题没做

Day 12
//噢今天爸爸过生日鸽了一天晚上回家补题补的非常暴躁第二题交了八百遍没过然后第二天就投身于另外的题目了呜呜呜完了回来好好看
T1：https://codeforces.com/problemset/problem/1362/A
题目：给出两个数，问一个数能否通过×2，×4，×8，÷2，÷4，÷8得到另一个数，求出最小操作次数
思路：水水水题
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>
#define ll long long
#define MAXN 100007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll a,b;
        scanf("%lld%lld",&a,&b);
        if(a==b) {
            printf("0\n");
            continue;
        }
        ll _a=max(a,b);
        ll _b=min(a,b);
        if(_a%_b!=0) {
            printf("-1\n");
            continue;
        }
        ll c=_a/_b;
        if(c%2!=0) {
            printf("-1\n");
            continue;
        }
        ll ans=0;
        while(c%8==0) {
            c>>=3;
            ans++;
        }
        while(c%4==0) {
            c>>=2;
            ans++;
        }
        while(c%2==0) {
            c>>=1;
            ans++;
        }
        if(c==1)  printf("%lld\n",ans);
        else printf("-1\n");
    }
    return 0;
}
T2: https://codeforces.com/problemset/problem/1362/B
//交了八百遍不对淦不知道是错哪里了
T3: https://codeforces.com/problemset/problem/1362/D
T4: https://codeforces.com/problemset/problem/1362/E
T5: https://codeforces.com/problemset/problem/1362/F

Day 13
T1:
//不想写了睡一觉来

Day 20 
//总是补之前的好像有点废啊
T1：https://codeforces.com/problemset/problem/686/A
题意：水水水题不太想写
下一题吧
T2：https://codeforces.com/problemset/problem/686/B
题意：给一串数字，希望可以变成非降序列。可以对这串序列做这样的操作：



Day 22    2.4
T1：https://codeforces.com/problemset/problem/777/A
题意：就是三个碗底下扣着个球，然后奇数此变换把左边的和中间的交换，偶数次把右边的和中间的交换，从左到右三个碗依次编号012，已知最后球所在碗的编号和变换次数，求一开始球所在碗的编号。
思路：一眼看过去就知道是规律题

T2：https://codeforces.com/problemset/problem/777/B
题意：夏洛克和教授玩牌，规则是每次出一张牌，点数小的被弹一下脑门。夏洛克的出牌顺序是知道的，但是教授耍赖出牌顺序可以随便改，要求的是教授最少被弹多少次脑门，夏洛克最多被弹多少次。
	  点数一样的话不弹。
思路：
	
Day 23 2.5
//每天都当鸽子，有一点点烦
T1：https://codeforces.com/problemset/problem/796/A
题意：在形如坐标系的一条路上建房子，每个房子距离相等相当于一个坐标点，然后女神住在坐标为m的房子里，每两栋房子之间的距离是10，有的房子住了人就把value记为0，有的房子没有住人会给出value，
	  给出可以建造的房子的value上限，求最近离女神多远。
思路：第一题总是水。分别找前面和后面满足条件的。遍历
#include<iostream>
#include<cstdio>
#include<bits/stdc++.h>

#define MAXN (int)1e5+7
#define ll long long

using namespace std;

int main() {
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    int arr[MAXN]={0};
    for(int i=1;i<=n;i++) {
        scanf("%d",&arr[i]);
    }
    int dist=99999;
    for(int i=1;i<m;i++) {
        if(arr[i]<=k&&arr[i]) {
            dist=min(dist,(m-i)*10);
        }
    }
    for(int i=m+1;i<=n;i++) {
        if(arr[i]<=k&&arr[i]) dist=min(dist,(i-m)*10);
    }
    printf("%d\n",dist);
    return 0;
}
T2：https://codeforces.com/problemset/problem/796/B
题意：还是转杯子。n个杯子排成一列，有些杯子下是洞，东西进去会直接掉下去。最开始把骨头放在第一个杯子里，然后输k组数，表示这两个杯子和杯子里的东西通过魔法换了位置，希望知道杯子里东西最
	  后在第几个里面。
思路：模拟
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<bits/stdc++.h>
#include<cstdio>

#define MAXN (ll)1e6+7
#define ll long long

using namespace std;

int hole[MAXN]={0};

int main() {
    int n,m,k;
    scanf("%d%d%d",&n,&m,&k);
    for(int i=1;i<=m;i++) {
        int x;
        scanf("%d",&x);
        hole[x]=1;
    }
    int pos=1;
    for(int i=1;i<=k;i++) {
        int a,b;
        scanf("%d%d",&a,&b);
        if(pos==a&&hole[pos]==0) {          //if(pos==a&&hole[a]==0)
            pos=b;
        }
        else if(pos==b&&hole[pos]==0) {		//if(pos==b&&hole[b]==0)   	//之前wa掉了是这么写的。接下来换到的那个位置是不是洞无所谓，要判断的是骨头是不是已经掉在洞里了
                pos=a;
            
        }
    }
    printf("%d\n",pos);
    return 0;
}

T3：https://codeforces.com/problemset/problem/796/C
题意：一直小狗想要黑银行的网，若干个银行是连在一起的，保证n个银行有n-1条边，图是连通图。先选择一个银行黑进去，接着沿边向其他的银行黑，每黑进一个银行，跟这个银行直接相连的银行代价+1，
	  跟这个银行隔着一个银行相连的银行代价+1，要求能够黑掉所有银行的电脑能力值（就是可以支付得起每一个代价的初始值）。
思路：就很显然肯定是跟最大值有关系，还有最大值-1，因为这个值有可能被加到最大值。每一个值最多会加两个1，只有跟开始的银行相连的点会只+1,那就要判断（刚开始选择的一定是初始的最大值）跟
	  初始点相连的点是不是全部的maxx-1，还是有其他的maxx-1需要+2；或者最大值有很多个，最大值是不是全部与初始值连起来只+1，还是其他地方也有要+2。
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
#include<vector>

#define MAXN (ll)1e6+7
#define ll long long

using namespace std;

struct Node{
    ll strengths;
    int x;
}bank[3*MAXN];
vector<int> tu[3*MAXN];
ll n,ma,x,y,ans1,ans2,l,k;
ll a[3*MAXN],b[3*MAXN];

using namespace std;

int main() {
	scanf("%lld",&n);
	ma=-0x7fffffff;
	for(int i=1;i<=n;i++) {
		scanf("%lld",&bank[i].strengths);
		ma=max(ma,bank[i].strengths);
		bank[i].x=i;
	}
	for(int i=1;i<n;i++) {
		scanf("%lld%lld",&x,&y);
		tu[x].push_back(y);
		tu[y].push_back(x);
	}
	for(int i=1;i<=n;i++) {
		if(bank[i].strengths==ma) {
			ans1++;
			a[ans1]=bank[i].x;
		}
		if(bank[i].strengths==ma-1) {
			ans2++;
			b[ans2]=bank[i].x;
		}
	}
	l=0;
	if(ans1==1) {
		for(ll i=0;i < tu[a[ans1]].size();i++) {
			int k=tu[a[ans1]][i];
			if(bank[k].strengths==ma-1) l++;
		}
		if(l==ans2) {
			printf("%lld\n",ma);
			return 0;
		}
		else {
			printf("%lld\n",ma+1);
			return 0;
		}
	}	
	bool flag=false;
	for(int i=1;i<=n;i++) {
		l=0;
		if(bank[i].strengths==ma) l++;
		for(ll j=0;j < tu[bank[i].x].size();j++) {
			int k=tu[i][j];
			if(bank[k].strengths==ma) l++;
		}
		if(l==ans1) {
			flag=true;
			break;
		}
	}
	if(flag) {
		printf("%lld\n",ma+1);
		return 0;
	}
	else printf("%lld\n",ma+2);
	return 0;
}
T4：https://codeforces.com/problemset/problem/796/D
T5：https://codeforces.com/problemset/problem/796/E

Day 25 2.8
T1:https://codeforces.com/problemset/problem/1480/A
题意：给一串字符，两个人依次把每一个字符改成自己想要的，必须改不能保持不变。第一个人想要字符串的字典序尽量小，第二个人想要字符串的字典序尽量大。求最后得到的字符串。
思路：模拟挨个改过去就是了
#include<iostream>
#include<cstdio>
#include<bits/stdc++.h>

#define MAXN (int)1e5+7
#define ll long long

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        char ch[55];
        scanf("%s",ch);
        int len=strlen(ch);
        for(int i=0;i<len;i++) {
            if(i%2==0) {
                if(ch[i]!='a') ch[i]='a';
                else ch[i]='b';
            }
            if(i%2==1) {
                if(ch[i]!='z') ch[i]='z';
                else ch[i]='y';
            }
        }
        printf("%s\n",ch);
    }
    return 0;
}

T2:https://codeforces.com/problemset/problem/1480/B
题意:勇士打小怪兽。给出勇士的攻击力和血量，再给一串小怪的攻击力，再给一串小怪的HP（一一对应），问勇士能不能打完这一串小怪（同归于尽也可）。
思路：一开始想的是把全部的伤害算出来然后跟生命比较（诶？？为啥不行），样例就没过去。嗷就是有可能虽然总的比较大但是有可能是有一下可以同归于尽的，虽然勇士的hp一下成了负数但是怪兽的血也
	  掉完了。啊那就应该顺着继续往下想呀！我不知道拐到哪里去了！
	  算掉全部的然后比较如果直接就小于勇士的hp那很好全都干掉。如果大于勇士的hp有可能是最后一击跟怪兽同归于尽了，所以就算如果不带最后一击那勇士的生命值是正是负。如果是负就说明前面还有
	  几下会把勇士的血打掉，如果是正的那就说明勇士是同归于尽了。最难搞的当然留在最后，所以最后是要跟攻击最大的同归于尽，
//趁过年没事好好学习！！！！
//到底是自己写的AC代码呜呜呜为啥我这么菜
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<bits/stdc++.h>
#include<cstdio>

#define MAXN (ll)1e6+7
#define ll long long

using namespace std;

ll a[MAXN],b[MAXN];

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll A,B,n;
        scanf("%lld%lld%lld",&A,&B,&n);
        ll maxx=-1;
        for(int i=1;i<=n;i++) {
            scanf("%lld",&a[i]);
            maxx=max(maxx,a[i]);
        }
        ll sum=0;
        for(int i=1;i<=n;i++) {
            scanf("%lld",&b[i]);
            sum+=ceil((double)b[i]/A)*a[i];    //这种地方还是要搞输出测试一下
        }
        if(sum<=B) printf("YES\n");
        else {
            if(B-sum+maxx>0) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}

T3:https://codeforces.com/problemset/problem/1480/C
//这是个交互题！！！
//睡起来看交互题把之前的都做掉
T4:https://codeforces.com/problemset/problem/1480/D
T5:https://codeforces.com/problemset/problem/1480/E

Day不知道多少了都，鸽了好久
2.20
T1：https://codeforces.com/problemset/problem/1459/A
//一个不知道为什么会wa掉的题，虽然题目没看懂但是误打误撞合上了，明明查了标程感觉跟我的明明一样但是就是wa掉了。
题意：同一张牌上写了红色和蓝色的数字，一共有n张牌，可以随意变换这些牌的顺序，可以组成两个n位的数，


Day 还是不知道都多少了，嘤嘤嘤天天玩气死了 2.22
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<bits/stdc++.h>

#define ll long long
#define MAXN 100007
#define MOD (ll)1e9+7

using namespace std;

/*
    先捋一下，前缀和怎么求啊
    要精确到现在某一个数，这个数不一定是整的一块，方便求我需要知道前面有几个块，先用等比数列求和公式求个数，然后用等差数列求和公式求和。
    个数递增是乘了前一个的2，记录现在是第几个块，就可以知道这一块是奇数块还是偶数块，这一块求和比较好求。
    所以总的需求有这些：
        现在是第几块（为了知道应该加奇数列还是偶数列）
        奇数块有多少（对所有的奇数求和)
        同理，偶数块有多少
        整块的一共有多少个数（算后边零散的）
*/

ll solve(ll x) {
    ll odd_num=0,even_num=0;   //记录奇数块和偶数块的数量
    ll odd_sum=0,even_sum=0,cnt=1;   //记录奇数块和偶数块的和
    ll sum=0;
    for(ll i=1,cnt=1,odd_num=0,even_num=0;i<=x;i+=i,cnt++) {
        if(cnt%2!=0) {
            //现在是第cnt个数字块，这个数字块有i个数，前面一共有odd_num个奇数数字块1，4，16
            ll temp=((fpow(4,odd_num)-1)%MOD)/3;
            sum+=(i%MOD)*(
            odd_num++;
        }   



int main() {
    ll l,r;
    scanf("%lld%lld",&l,&r);
    printf("%lld\n",(solve(r)%MOD-solve(l-1)%MOD)%MOD);   //前缀和
    return 0;
}
//没写完，数学真难

//这一版是错的，淦我还以为自己机智坏了，明天继续改
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<bits/stdc++.h>

#define ll long long
#define MAXN 100007
#define MOD (ll)1e9+7

using namespace std;

/*
    先捋一下，前缀和怎么求啊
    要精确到现在某一个数，这个数不一定是整的一块，方便求我需要知道前面有几个块，先用等比数列求和公式求个数，然后用等差数列求和公式求和。
    个数递增是乘了前一个的2，记录现在是第几个块，就可以知道这一块是奇数块还是偶数块，这一块求和比较好求。
    所以总的需求有这些：
        现在是第几块（为了知道应该加奇数列还是偶数列）
        奇数块有多少（对所有的奇数求和)
        同理，偶数块有多少
        整块的一共有多少个数（算后边零散的）
*/

ll solve(ll x) {
    ll odd_num=0,even_num=0;   //记录奇数块和偶数块的数量
    ll cnt=1;   //记录奇数块和偶数块的和
    ll sum=0;
    for(ll i=1,cnt=1,odd_num=0,even_num=0;i<=x;i+=i,cnt++) {
        if(cnt%2!=0) {
            //现在是第cnt个数字块，这个数字块有i个数，前面一共有odd_num个奇数
            sum+=(((((2*odd_num+1)%MOD)+((2*((odd_num+i)%MOD)-1)%MOD))%MOD)*(i%MOD))%MOD;
            odd_num+=i;
            x-=i;
        } 
        if(cnt%2==0) {
            sum+=(((((2*even_num+2)%MOD)+((2*((even_num+i)%MOD))%MOD))%MOD)*(i%MOD))%MOD;   
            even_num+=i;
            x-=i;
        }
    }
    if(cnt%2==0) {//接下来该加奇数
        sum+=(((((2*odd_num+1)%MOD)+((2*((x-even_num)%MOD)-1)%MOD))%MOD)*((x-odd_num-even_num)%MOD))%MOD;
    }
    else {//接下来该加偶数
        sum+=(((((2*even_num+2)%MOD)+((2*((x-odd_num)%MOD))%MOD))%MOD)*((x-odd_num-even_num)%MOD))%MOD;  
    }
    return sum%MOD;
}


int main() {
    ll l,r;
    scanf("%lld%lld",&l,&r);
    printf("%lld\n",(solve(r)%MOD-solve(l-1)%MOD)%MOD);   //前缀和
    return 0;
}

T1:https://codeforces.com/problemset/problem/1151/A
题意：碱基序列ATCG是一个目标序列。给出一串大写字母，对每个字母可以变为前一个或者后一个（注意A的前一个是Z，Z的后一个是A），最少进行多少次操作可以使ATCG是变后字符串的子串（只在原串前后
	  去掉若干个字符。
思路：字符串长度最大是50，这么小的数不暴力都对不起这题。
#include<iostream>
#include<cstdio>
#include<bits/stdc++.h>

#define MAXN (int)1e5+7
#define ll long long

using namespace std;

char ch[55];

int main() {
    //既然n只有50，我要开始暴力了
    //ACTG
    int n;
    scanf("%d",&n); 
    scanf("%s",ch);
    int ans=0x7fffffff;
    for(int i=3;i<n;i++) {
        int sum=0;
        sum+=min(abs(ch[i]-'G'),26-abs(ch[i]-'G'));
        sum+=min(abs(ch[i-1]-'T'),26-abs(ch[i-1]-'T'));
        sum+=min(abs(ch[i-2]-'C'),26-abs(ch[i-2]-'C'));
        sum+=min(abs(ch[i-3]-'A'),26-abs(ch[i-3]-'A'));
        ans=min(ans,sum);
    }
    printf("%d\n",ans);
    return 0;
}

Day还是不知道多少 2.23
T1：https://codeforces.com/problemset/problem/1025/A
题意：每次操作可以把字符串中出现次数大于1的字母全部变为另一个字母，问是否可以多次操作后把字符串中的所有字符变为同一个
思路：稍微一想就知道只要有一个字符出现次数大于一，就可以把所有字符变成同一个。
#include<iostream>
#include<cstdio>
#include<bits/stdc++.h>

#define MAXN (int)1e5+7
#define ll long long

using namespace std;

int main() {
    int n;
    scanf("%d",&n);
    string s;
    cin>>s;
    int num[30]={0};
    for(int i=0;i<n;i++) {
        num[s[i]-'a']++;
    }
    int flag=0;
    for(int i=0;i<26;i++) {
        if(num[i]>1) flag=1;
    }
    if(flag==0&&n>1) printf("NO\n");      //注意这里的n>1是个坑。判断是不是每个字符都只出现了一次，有一种特殊情况是字符串中只含有一个字符
    else printf("YES\n");
    return 0;
}

T2：https://codeforces.com/problemset/problem/1025/B
题意：给出若干个字符对，是否可以找出一个数字，这个数字可以被没对字符中的至少一个整除，如果有输出任意一个满足条件的数，否则输出-1.
思路：好像有简单办法稍微用点数学知识。
	  第一下想到的是暴力。算出第一对数字两个数所有的质因数，然后一个一个一对一对的判断。然后又觉得有点太暴力了，就查了题解。发现这么暴力真的可以。然后代码不太会写qwq
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define MAXN (int)1e5+7

int a[150007],b[150007];
int pre[150007]={0};

int main() {
	ll n;
	scanf("%lld",&n);
	//scanf("%lld%lld",&a1,&b1);
	for(int i=1;i<=n;i++) {
		scanf("%d%d",&a[i],&b[i]);
	}

	int cnt=0;
	for(ll i=2;i*i<=a[1];i++)    //这是找出质因数的部分，如果不会还是记一下的好
		if(a[1]%i==0) {
			pre[++cnt]=i;
			while(a[1]%i==0) 
				a[1]/=i;
		}
	if(a[1]>1) pre[++cnt]=a[1];   //注意这一句，不要漏掉最后一个质数

	for(ll i=2;i*i<=b[1];i++) 
		if(b[1]%i==0) {
			pre[++cnt]=i;
			while(b[1]%i==0) b[1]/=i;
		}
	if(b[1]>1) pre[++cnt]=b[1];

	for(int i=1;i<=cnt;i++) {   //循环第一对所有的质因数
		int flag=0;
		for(int j=2;j<=n;j++) {    //循环后边所有的数
			if(a[j]%pre[i]!=0&&b[j]%pre[i]!=0) {
				flag=1;
				break;
			}
		}
		if(flag==0) {
			printf("%d\n",pre[i]);
			return 0;
		}
	}
	printf("-1\n");
	return 0;
}
//大佬还是大佬

T3：https://codeforces.com/problemset/problem/1025/C
//这个题也可耻地看了题解，最后真的是简单题
//一来没啥思路，知道思路了不会写代码
题意：一串字符串只含有字符b和w，可以在字符串的任意位置截断字符串，然后将两段字符分别对称之后再首尾相连得到新的字符串。进行若干次操作，问最多得到形如"bwbwbwbw……"这样的子串最长是多长。
思路：发现问题就可能是突破点——为啥进行若干次变换最大值是定值呢？
	  中间截断然后首尾颠倒等价于将原字符串首尾相连形成一个环，在环的任意处截断形成新的字符串
//查题解恍然大悟知道了思路，然后不会写代码
//学学，学学
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
#include<vector>

#define Maxn (int)1e5+7
#define ll long long

using namespace std;

int main() {
	char s[2*Maxn];
	scanf("%s",s);
	int len=strlen(s);
	memcpy(s+len,s,len);    //原字符串后边再连一段原字符串
	len<<=1;
	int ans=1;
	for(int i=1;i<len;i++) {    //这样就相当于是当环跑了
		int cnt=1;
		while(s[i]!=s[i-1]&&i<len) cnt++,i++;    
		ans=max(ans,cnt);
	}
	len>>=1;
	printf("%d\n",min(len,ans));    //这一步是个坑。有可能原字符串就是bwbwbwb这样的
	return 0;
}
//学学！
//学大佬打代码之前自己写了一版%的，可以再试着改改我觉得可以

2.24
T2：https://codeforces.com/problemset/problem/1185/B
//这题真的好考验代码能力啊
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define MAXN (int)1e5

char a[MAXN*10+7],b[MAXN*10+7];


int main() {
	int n;
	scanf("%d",&n);
	while(n--) {
		scanf("%s%s",a,b);
		int lena=strlen(a);
		int lenb=strlen(b);
		int i=0,j=0;
		int flag=0;
		if(lena>lenb) {
			printf("NO\n");
			continue;
		}
		for(i;i<lena;i++) {
			int counta=1;
			for(counta; ;counta++) 
				if(a[i+counta]!=a[i]) break;
			i+=counta-1;
			//  printf("%d %d\n",counta,i);

			int countb=1;
			if(b[j]!=a[i]) {
				flag=1;
				printf("NO\n");
				break;
			}
			for(j;j<lenb;j++) {
				for(countb; ;countb++) 
					if(b[j+countb]!=b[j]) break;
				j+=countb;
				break;
			}
			// printf("%d %d\n",countb,j);

			if(counta>countb) {
				flag=1;
				printf("NO\n");
				break;
			}
		}
		if(j!=lenb&&flag==0) {
			printf("NO\n");
			continue;
		}
		if(flag==0) printf("YES\n");
	}
	return 0;
}
//仔细看看吧，瞄了一眼题解恍然大悟才会做的



2.27 后天开学呜呜呜

T2：https://vjudge.net/problem/CodeForces-1180B/origin
不知道为啥哇的一道题，虽然代码和算法都很丑陋但是我感觉思路没有大问题呀呜呜呜
//我的
#include <bits/stdc++.h>
using namespace std;

#define ll long long
#define MAXN (int)1e5+7

//char mat[50005][50005];
int arr[MAXN];

int main() {
	int n;
	scanf("%d",&n);
	int pos=0,neg=0;
	int max_pos=-1,max_neg=1;
	for(int i=1;i<=n;i++) {
		scanf("%d",&arr[i]);
		if(arr[i]>=0) {
			pos++;
			max_pos=max(max_pos,arr[i]);
		}
		if(arr[i]<0) {
			neg++;
			max_neg=min(max_neg,arr[i]);
		}
	}
	if((pos%2==0&&neg%2==0)||(pos%2==1&&neg%2==1)) {
		if(arr[1]>=0) {
			printf("%d",-arr[1]-1);
		}
		else printf("%d",arr[1]);
		for(int i=2;i<=n;i++) {
			if(arr[i]>=0) {
				printf(" %d",-arr[i]-1);
			}
			else printf(" %d",arr[i]);
		}
		printf("\n");
		return 0;
	}

	int flag=0;  //有没有保留过
	if(pos%2==1&&neg%2==0) {
		if(arr[1]==max_pos) {
			printf("%d",arr[1]);
			flag=1;
		}
		else {
			if(arr[1]<0) {
				printf("%d",arr[1]);
			}
			else {
				printf("%d",-arr[1]-1);
			}
		}

		for(int i=2;i<=n;i++) {
			if(arr[i]==max_pos&&flag==0) {
				printf(" %d",arr[i]);
				flag=1;
			}
			else {
				if(arr[i]<0) {
					printf(" %d",arr[i]);
				}
				else {
					printf(" %d",-arr[i]-1);
				}
			}
		}
		printf("\n");
		return 0;
	}

	if(pos%2==0&&neg%2==1) {
		if(arr[1]==max_neg) {
			printf("%d",-arr[1]-1);
			flag=1;
		}
		else {
			if(arr[1]<0) {
				printf("%d",arr[1]);
			}
			else {
				printf("%d",-arr[1]-1);
			}
		}

		for(int i=2;i<=n;i++) {
			if(arr[i]==max_neg&&flag==0) {
				printf(" %d",-arr[i]-1);
				flag=1;
			}
			else {
				if(arr[i]<0) {
					printf(" %d",arr[i]);
				}
				else {
					printf(" %d",-arr[i]-1);
				}
			}
		}
		printf("\n");
		return 0;
	}
	return 0;
}//非常丑陋，好大段的重复

//大佬的AC代码
#include<iostream>
#include<stdio.h>
#include<cstring>
#include<algorithm>
using namespace std;
const int maxx = 1e5+10;
struct node
{
    int x;
    int d;
} a[maxx];

int cmp1(struct node a,struct node b)
{
    return a.x<b.x;
}

int cmp2(struct node a,struct node b)
{
    return a.d<b.d;
}


int main()
{
    int n;
    while(cin>>n)
    {
        int i;
        for(i=0; i<n; i++)
        {
            scanf("%d",&a[i].x);
            if(a[i].x<0)
                a[i].x = -a[i].x-1;   //转换成非负数
            a[i].d = i;       // 存下每个的编号，因为输出的时候顺序是不变的
        }
        sort(a,a+n,cmp1);    //从小到大排序
        if(n&1)
        {
            for(i=0; i<n-1; i++)
            {
                a[i].x = -a[i].x-1;
            }
            sort(a,a+n,cmp2);      //按编号从小到大排序
            for(i=0; i<n-1; i++)
            {
                printf("%d ",a[i].x);
            }
            printf("%d",a[i].x);
            printf("\n");
        }
        else
        {
            for(i=0; i<n; i++)
            {
                a[i].x = -a[i].x-1;
            }
            sort(a,a+n,cmp2);
            for(i=0; i<n; i++)
            {
                if(i==0)
                    printf("%d",a[i].x);
                else
                    printf(" %d",a[i].x);
            }
            printf("\n");
        }
    }
    return 0;
}


T3：https://vjudge.net/problem/CodeForces-1180C/origin
辛辛苦苦用vector模拟了半天，结果居然stl里就有双向列表deque？！
其实我觉得我vector模拟的好像没啥问题呀，可惜搞不到数据测试

//愚蠢的vector模拟
//之后要改的
#include<iostream>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>
#include<bits/stdc++.h>
#include<cstdio>
#include<algorithm>
#include<vector>

#define Maxn (int)1e5
#define MOD (int)1e9+7
#define ll long long

using namespace std;

struct Node{ 
	ll val,idex;
}maxn;

vector<ll> arr;
ll pre[Maxn+7][3];

void func_pre(ll idex) {
	for(int i=1;i<=idex;i++) {
		pre[i][1]=arr[0];
		pre[i][2]=arr[1];
		
		if(arr[0]>arr[1]) {
			arr.push_back(arr[1]);
			arr.erase(arr.begin()+1,arr.begin()+2);
		}
		else {
			arr.push_back(arr[0]);
			arr.erase(arr.begin(),arr.begin()+1);
		}
		/*
		for(int j=0;j<=4;j++) {
			cout<<arr[j]<<' ';
		}
		cout<<endl;
		*/
	}
}

int main() {
	ll n,q;
	scanf("%lld%lld",&n,&q);
	maxn.val=-1;
	for(int i=1;i<=n;i++) {	
		ll x;
		scanf("%lld",&x);
		arr.push_back(x);
		if(arr[i-1]>maxn.val) {
			maxn.val=arr[i-1];
			maxn.idex=i-1;
		}
	}
	// printf("%lld %lld\n",maxn.val,maxn.idex);
	func_pre(maxn.idex);
	for(int i=1;i<=q;i++) {
		ll m;
		scanf("%lld",&m);
		if(m<=maxn.idex) {
			printf("%lld %lld\n",pre[m][1],pre[m][2]);
		}
		else {
			printf("%lld %lld\n",maxn.val,arr[(m-maxn.idex)%(n-1)]);
		}
	}
	return 0;

}

//deque的正解
#include<iostream>
#include<deque>//双向队列 
using namespace std;
#define ll long long
const int MAXN=300010;
int n,m,maxx=0,num=0,ans[MAXN];
deque<ll> q;
 
struct node{
	int r,l;
}t[MAXN];
 
void solve(){
	while(1){
		int x=q.front();
		q.pop_front();
		int y=q.front();
		q.pop_front();
		if(x==maxx){
			q.push_front(y);
			for(int i=1;i<=n-1;i++){
				y=q.front();
				q.pop_front();
				ans[i]=y;
			}
			break;
		}
		else{
			num++;	
			t[num].l=x;
			t[num].r=y;
		
			if(x>y){
				q.push_front(x);
				q.push_back(y);
			}
			else{
				q.push_front(y);
				q.push_back(x);
			}
		}
	}
} 
 
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		int a;
		cin>>a;
		maxx=max(a,maxx);
		q.push_back(a);//放在队尾（右） 
	}
	solve();//进行模拟操作 
	for(int i=0;i<m;i++){
		ll c;
		cin>>c;
		if(c<=num) cout<<t[c].l<<" "<<t[c].r<<endl;
		else{
			c-=num;
			c%=(n-1);
			if(c==0) c=n-1;
			cout<<maxx<<" "<<ans[c]<<endl;
		}
	} 
	return 0;
}

//秃头也要看deque和线段树，昨天和今天都被坑了


3.7 ICPC区域赛热身赛（？）

链接：https://ac.nowcoder.com/acm/contest/12606/H
来源：牛客网

题目描述 


Alice and Bob are playing a game on a simple connected graph with N nodes and M edges.
Alice colors each edge in the graph red or blue.
A path is a sequence of edges where each pair of consecutive edges have a node in common. If the first edge in the pair is of a different color than the second edge, then that is a ''color change.''
After Alice colors the graph, Bob chooses a path that begins at node 1 and ends at node N. He can choose any path on the graph, but he wants to minimize the number of color changes in the path. Alice wants to choose an edge coloring to maximize the number of color changes Bob must make. What is the maximum number of color changes she can force Bob to make, regardless of which path he chooses? changes she can force Bob to make, regardless of which path he chooses?
/*题目粘成啥样我管不了了
 *一个简单的最短路问题，bfs就可以解决
 *题意很好懂，看完就知道答案是最短路径-1
 *问题就在我不会用bfs写最短路，我只会dfs写最短路
 *但是我现在好像会了
*/
//dfs写完递归超限了，太多层，而且1e5x1e5的数组也太大了点（甚至尝试了用string数组存，因为不会用二维的vector）。
//更神奇的是做这个题之前想到了所编代码的点，就是没想起来bfs是怎么一回事
#include<bits/stdc++.h>

#define MAXN (int) 1e5
#define MOD  (int)1e9+7
#define ll   long long

using namespace std;

//尝试了八百遍了吧有
vector<vector<int> > mat(MAXN+7);
// int f[MAXN+7];
int dis[MAXN+7];
int q[MAXN+7];

int main() {
    int n, m ;
    scanf("%d%d",&n, &m) ;
    for (int i = 1; i <= m; i ++) {
        int x, y;
        scanf("%d%d", &x, &y);
        mat[x].push_back(y);
        mat[y].push_back(x);
    }
    
    int head = 1, tail=2;
    q[head] = 1;
    
    while(head < tail) {
        int len  = mat[q[head]].size();      //队头队尾，用数组模拟队列。每次都要把所有扩展到的结点加入队列，最先到达的目标点就是最短路
        int temp = q[head];
        for(int i = 0; i<len; i ++) {
            if(dis[mat[temp][i]] == 0) {     //dis存储最短路长度，顺便查重
                q[tail++] = mat[temp][i]; 
                dis[mat[temp][i]] = dis[temp] + 1;      //下一点继承它的父节点（图里没有这个概念吧但是就是这个意思）的最短路，每个点存的都是最短路（可以保证）
            }
        }
        head++;
    }
    printf("%d\n",dis[n]-1);  
    return 0;
}
//滚去多刷几道题


3.15
https://codeforces.com/contest/1496/problem/B
题面就不嗦了，自己再捋一遍思路
稍微要想一下，首先找到mex，因为数列是一个本该连续的数列要找到第一个没有出现的整数，排序后把索引和元素对一下就可以找到。然后要注意(max+mex)/2的值，要把这个值添到数列里，算出来的数不是
max也不是mex是一个另外的数，也就是说不管算多少遍k是多少，要插进数列里的这个数是不变的。那就需要判断这个数，有没有在原本的数列里出现过。
最后考虑特殊情况（根据题目给的样例)，如果k是0，那不同的数字直接就是n个；如果给出的数列就是连续的呢，那么第一个没有出现的整数就是这串连续数列的下一个，max就是最后一个，要插入的数是这
两个数除以2，题目有提到向上取整，所以得到的数就是n，也就是这串数列的下一个，依此类推，后面的k-1次操作都是往后添加一个数，答案就是n+k。
实际打代码还有一些要注意到的细节。
一开始卡在了没注意到（max+mex）/2的特点
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<cmath>
#include<algorithm>
#include<vector>
#include<set>
#include<bits/stdc++.h>

using namespace std;

#define ll long long
#define MAXN (int)1e5
#define MOD (int)1e9+7

int main() {
    int t;
    scanf("%d",&t);
    vector<ll> arr(MAXN+7);
    while(t--) {
        int n,k;
        scanf("%d%d",&n,&k);
        for(int i=0;i<n;i++) {
            scanf("%lld",&arr[i]);
        }
        if(k==0) {
            printf("%d\n",n);
            continue;
        }

        sort(arr.begin(),arr.begin()+n);		//这里排序跟数组排序有一点不一样（每次都要疑惑啊为啥报错）
        int temp=-1;
        for(int i=0;i<n;i++) {              //这里，找到第一个没有出现的整数，之前想到了没敢打
            if(arr[i]>i) {
                temp=i;
                break;
            }
        }
        // printf("temp=%d\n",temp);
        if(temp==-1) {    //本来就是连续的数列
            printf("%d\n",n+k);
            continue;
        }
        ll ins=ceil((temp*1.0+arr[n-1]*1.0)/2);			//还有这里，要先得到小数然后向上取整
        vector<ll>::iterator it=lower_bound(arr.begin(),arr.begin()+n,ins);		//前面尖括号里要跟定义vector时候的数据类型一致，最后一个参数也要跟vector类型一致
        int idx=&*it-&arr[0];			//迭代器先取值然后取址，要找的是第几个数就得到几，不是索引
        // printf("idx=%d\n",idx);
        if(arr[idx]!=ins) {
            printf("%d\n",n+1);
        }
        else printf("%d\n",n);
    }
    return 0;
}
//努力提升代码能力orz

//是的我又要接着往后续了
https://codeforces.com/problemset/problem/1499/D
//熬了三天淦发现关键算法错了

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
#include<string>
#include<vector>
#include<set>
#include<map>
#include<bits/stdc++.h>
 
using namespace std;
 
#define MAXN (int)1e5
#define MOD (int)1e9+7
#define llmaxn 9223372036854775807
#define ll long long
 
ll primec[MAXN]={0};
 
//还是要背模板啊背模板
 
int p[(int)2e7+7];
int pf[(int)1e7+7]={0};
int topp=0;
int f[(int)1e7+7]={0};
 
void prime() {
    for (int i=2;i<10000002;i++)   //不要等号，因为判别没有=，不然会把最后一个数包括进去
	{
        // cout<<i<<' ';
		if (!pf[i])   
			p[++topp]=i;
		for (int j=1;j<=topp&&p[j]*i<10000002;j++)
		{
            // cout<<1<<' ';
			pf[i*p[j]]=true;     //相乘之后倍数一定不是质数，往后筛了好几位
			if (i%p[j]==0)break;   //6会被2和3筛，加上这一句可以使一个数只被一个质数筛掉，可以提高效率
		}
	}
    // cout<<1<<' ';
    // for(int i=1;i<=100;i++) cout<<p[i]<<' ';
}
/*
int pc[MAXN+7]={0};

int doit(int x) {
    int tot=0;
    for(int i=1;i*i<=x;i++) 
        if(x%i==0) { 
            pc[++tot]=i;
            pc[++tot]=x/i;
        }
    return tot;
}
*/
int func(int x) {
    int tot=0;
    for(int i=1;p[i]<=x;i++) 
        if(x%p[i]==0) tot++;   //为啥看不懂我这在干嘛了，质因子的总数
    
    // printf("primetot=%d\n",tot);
 
    int a=2,q=tot;
    int ans=1;
    if(q==0) return 1;
    else {
        while(q>0) {
            if(q&1) ans*=a;
            a*=a;
            q>>=1;
        }
    }
    // printf("tempans=%d\n",ans);
    return ans;
}
 
int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll c,d,x;
        scanf("%lld%lld%lld",&c,&d,&x);
        prime();    //求质数
        // int tot=doit(x);
        ll ans=0;
        for(ll i=1;i*i<=x;i++) {
            if(x%i==0) {
                int cnt=(i+d)/c;
                if(cnt&&f[cnt]==0&&(i+d)%c==0) {
                    f[cnt]=1;
                    ans+=func(cnt);
                }
                if(i*i!=x) {
                    cnt=(x/i+d)/c;
                    if(cnt&&f[cnt]==0&&(x/i+d)%c==0) {
                        f[cnt]=1;
                        ans+=func(cnt);
                    }
                }
            }
        }
        memset(f,0,sizeof(f));
        printf("%lld\n",ans);
    }
    return 0;
}

//1e7的数据范围哈，欧拉筛是个O(n)的，快速幂是个log的，求因数是个根号的，叠在一起又加在一起是要被卡的呜呜呜，还经历了好几次的RE呜呜呜，真难。
//好不容易以为自己会了的数论呜呜呜
//找到大佬的代码，用埃氏筛好一点
