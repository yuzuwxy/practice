Day1 
//今天份的不想学习
//只做了四道题，剩下一道图论一道线性动态规划之后补

T1 ： https://codeforces.com/problemset/problem/1472/A
题意：给出纸张的长和宽，只有偶数可以继续裁剪。最终能够得到的纸张数是否大于等于指定数目。
思路：很显然最终可以得到的纸张数=裁剪“长” * 裁剪“宽”， 转化为求一个偶数最终能够分为几个奇数————一直除2看能除几次，然后根据（我没有的）数学知识是求2的次幂，怕卡时间写了快速幂
//也不知道说的啥，上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

long long ans;
long long poww;
long long h, w, n;
int t;

long long kpow(long long _poww) {     //变量名实在太丑了点
    long long _ans=1;
    long long b=2;
    if(_poww==0) {
        _ans=1;
        return _ans;
    }
    while(_poww>0) {
        if(_poww&1) 
           _ans=_ans*b;
        b=b*b;
        _poww=_poww>>1;
    }
    return _ans;    //这是快速幂的部分（无情的模板机器
}

long long doit (long long x) {
    poww=0;
    while(!(x&1)) {        //位运算稍微快一点点
        x=x>>1;
        poww++;            //这个是看可以除几次2
    }
    return kpow(poww);
}

int main() {
    scanf("%d", &t) ;
    for(int i = 1; i <= t; i ++) {
        scanf("%lld%lld%lld", &w, &h, &n);
        ans = doit(w) * doit(h);
        if(ans >= n) {
            printf("YES\n");
            continue;
        }
        printf("NO\n");
    }
    return 0;
}
//啊签到题罢辽(但是说不定还有简单做法？

T2 ： https://codeforces.com/problemset/problem/1472/B
题意：给出一串只有1和2的序列，判断是否可以把这个序列分成两个子序列，使两个子序列的所有数之和相对（我也不知道在说啥反正就这个意思
题解：突破点其实在这一串数只有1和2来着（一开始没看见吓死了），稍微要想一下。如果这一串数满足，应该有以下几点特征：
      1.所有数之和不能是奇数，必须是偶数
      //然后思考如果是偶数就一定满足了吗？
      //和是偶数的话，说明1的数量一定是偶数，2的数量可能是奇数可能是偶数。
      //如果2的数量是偶数，那就一定可以，最起码存在两组分别有一半1和一半2；如果2的数量是奇数，设2的数量是y,1的数量是x,满足要求的话也就是2y-x可以对半分，啊那就显然可以。
      //然后注意特殊情况，1的数量是0的话，2的数量是奇数也不行
      2.1的数量为0时，2的数量不能是奇数

//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100010

int t;
int n;
int w[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        scanf("%d",&n);
        int two=0;
        int one=0;
        int ww=0;
        for(int j=1;j<=n;j++) {
            scanf("%d",&w[j]);
            if(w[j]==1) one++;
            if(w[j]==2) two++;
            ww+=w[j];
        }
        if(ww%2==1) {
            printf("NO\n");
            continue;
        }
        if((one==0)&&two%2!=0) {
            printf("NO\n");
            continue;
        }
        printf("YES\n");
    }
    return 0;
}
//稍微还是有点难想吧，题做多了可能敏感度就上来了（？）

T3 ： https://codeforces.com/problemset/problem/1472/C
题意：给出数字序列，下标从1开始，随机选一个下标i开始走，value加上a(i),下一步走到i+a(i),直到走到没法再走。要找出这个下标，使结束时的value最大。
思路：第一反应可能是模拟，一个一个扫过去，但是时间复杂度就很高。所以想到倒推，value[i]=a[i]+value[i+a[i]]
//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

int t=0;
int n=0;
int a[MAXN];
int dp[MAXN]={0};
int ans=0;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            scanf("%d",&a[i]);
        }
        ans=0;
        for(int i=n;i>=1;i--) {
            if(i+a[i]<=n) {
                dp[i]=a[i]+dp[i+a[i]];      //并不是动规，稍微被误导了以下
            }
            else {
                dp[i]=a[i];
            }
            ans=max(ans,dp[i]);
        }
    printf("%d\n",ans);
    }
    return 0;
}
//不太难，偶尔还是要自己想一想感受一下脑子的存在

T4 ： https://vjudge.net/problem/CodeForces-1472/D
题意：奇偶游戏。Alice选偶数加分，Bob选奇数加分，同时两人也可以ban掉对方选的数，当两人最佳发挥时，谁可以最终赢得比赛。
思路：首先思考最佳发挥是怎么发挥法。Alice要总能选到对自己有利的数，每一回合要决定pick还是ban，最终的目的是赢，贪心看，比较pick的数较大还是ban的数较大，就可以确定是ban还是pick；Bob同理。
      所以要对偶数和奇数分别进行排序，然后从大向小遍历。
//还是简单粗暴的上代码写注释

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

int t;
ll totA,totB;
ll jishu[MAXN],oushu[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        int n;
        scanf("%d",&n);
        int ji=1,ou=1;
        for(int j=1;j<=n;j++) {
            ll num;
            scanf("%lld",&num);
            if(num%2==1) {
                jishu[ji]=num;        //奇数和偶数分别放在不同的数组里
                ji++;
            }       
            else {
                oushu[ou]=num;
                ou++;
            }
        }
        sort(jishu,jishu+ji);
        sort(oushu,oushu+ou);
        ji--;
        ou--;   
        totA=0;
        totB=0;
        for(int j=0;j<n;j++) {
            if(j%2==0) {   //Alice的回合
                if((ou==0)&&(ji>0)) {    //如果偶数已经选完，那现在势必是要ban掉奇数
                    ji--;
                    continue;
                }
                if(jishu[ji]<oushu[ou]) {    //如果没有选完，并且pick比ban更有利
                    totA+=oushu[ou];
                    ou--;
                }
                else {
                    if(ji>0) ji--;
                }
                //printf("%lld\n",totA);
            }
            else {
                if((ji==0)&&(ou>0)) {     //Bob同理
                    ou--;
                    continue;
                }
                if(jishu[ji]>oushu[ou]) {
                    totB+=jishu[ji];
                    ji--;
                }
                else {
                    if(ou>0) ou--;
                }
            }
        }
        if(totA>totB) printf("Alice\n");
        if(totA<totB) printf("Bob\n");
        if(totA==totB) printf("Tie\n");
    }   
    return 0;
}

//稍微想一下下，关键在怎么才是最佳发挥

T5 ： https://vjudge.net/problem/CodeForces-1472/E
//这个是后来补的题
题解：就是给出几个矩形的长和宽，然后判断这个矩形是否可以将某个矩形完全覆盖（不包含等号），如果可以就输出被覆盖的矩形的索引，如果没有，就输出-1.
思路：题目中说给出的矩形的“长”和“宽”不一定哪个大，啊啊不知道怎么说。反正根据小学生思维，大的就看作长，小的就看作宽，那其实就无所谓比较的方法了（题目里说的站着或躺着），就可以直接分别比较
    两组数据里较小的和较大的。肯定不能一个一个挨个比啊，直接按照矩形的长把数据排序，只要那么对于第i个矩形是满足条件的矩形，就是1~i-1个矩形里最小的宽比第i个矩形的宽小（啊数学的存在与恒成立
    问题）。然后考虑特殊情况，可能会这样，就是说前面有一个长和宽都比当前这个矩形b小的矩形a，但是现在这个前面有一个长和b一样但是宽比a还要小的矩形c，那么最后找到的可以放在b上矩形是c，但这样是
    错误答案。为了避免这种情况的发生，把相同长的矩形按照宽降序排序。
    以及返回索引应该要存储原来数据的顺序。
#include<cstdio>
#include<iostream>
#include<string>
#include<cstring>
#include<algorithm>
#include<math.h>

using namespace std;

struct Node {
    int maxx,minn;
    int num;          //用来存储原来的顺序
    int ans;
}mat[200010];               //涉及到多个关键词排序，用sort的话需要建立结构体

int t;
int n;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int min(int a,int b) {
    if(a<b) return a;
    return b;
}

bool cmp1(Node a,Node b) {
    if(a.maxx!=b.maxx) return a.maxx<b.maxx;
    return a.minn>b.minn;
}

bool cmp2(Node a,Node b) {
    return a.num<b.num;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            int h,w;    
            scanf("%d%d",&h,&w);
            mat[i].maxx=max(h,w);     
            mat[i].minn=min(h,w);      //转换长和宽
            mat[i].num=i;
            mat[i].ans=-1;
        }
        sort(mat+1,mat+1+n,cmp1);
        int _min=1;             //标记当前最小的宽在排好序的数组里的索引
        for(int i=2;i<=n;i++) {
            if(mat[i].minn<mat[_min].minn) {
                _min=i;
            }
            if(mat[i].minn>mat[_min].minn) {
                mat[i].ans=mat[_min].num;
            }
        }
        sort(mat+1,mat+1+n,cmp2);      //按照num排序，也就是回到原来输入的顺序
        printf("%d",mat[1].ans);
        for(int i=2;i<=n;i++) {
            printf(" %d",mat[i].ans);        //不要末尾空格
        }
        printf("\n");
    }
}

//做出来感觉也不咋难（？）

T6 ： https://codeforces.com/problemset/problem/1472/F
//传说中的线性动态规划，不会做，之后补
//嘤我还找规律了结果是错的
//因为不会所以没有题解


T7 ： https://codeforces.com/problemset/problem/1472/G
//显然是道图论题，题目都么的看呜呜呜
//之后有机会补
//图论怎么可能有题解呢（划掉）

Day 2

T1 :  https://codeforces.com/problemset/problem/1454/A
题意：给出数字n，要求对1~n之内的数字进行排列，要求排列得到的数列arr[i]!=i。
思路：题意比较简单，类比之前有道题（啊自己写的深搜递归）是输出1~n之内所有数字所有排列方法，可以用同样的方法对每一位的数字枚举递推，到最后一位数都满足条件，就输出得到的这个数列，同时标记
    已经得到过了，之后的深搜不用往下搜了。
//肯定还有更简单的办法

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

int arr[110];
int flag=0;
int f[110]={0};

void doit(int n,int cnt) {
    if(cnt==n+1) {
        flag=1;
        printf("%d",arr[1]);
        for(int i=2;i<=n;i++) {
            printf(" %d",arr[i]);
        }
        printf("\n");
        return ;
    }

    for(int i=1;i<=n;i++) {
        if(!f[i]&&(cnt!=i)&&flag==0) {     //这个数没有排列过&&arr[i]!=i&&还没有得到过正确的数列
            arr[cnt]=i;
            f[i]=1;
            doit(n,cnt+1);      //继续往下搜
            f[i]=0;                     //状态还原
        }
    }
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {    
        int n;
        scanf("%d",&n);
        flag=0;
        doit(n,1);
    }
    return 0;
}

T2 ： https://codeforces.com/problemset/problem/1454/B
题意：给出一列数字，玩家随机选择索引，获胜者的索引有这样的特征————这个数字在数列中只出现了一次，并且这个数字是所有只出现过一次的数字中最小的数字
思路：水水水水题。sort排个序，存储原来的下标，遍历就完事。
//然后猛然发现我这题居然错了一遍！惊了！！！
#include<cstdio>

int main() {
	int n,t;
	int a[200010],tem,a2[200010],s=0;     //直接把输入的数字作为下标
	scanf("%d",&t);
	while(t--) {
		s=0;
		scanf("%d",&n);
		for(int i=0;i<n+1;++i) {
			a[i]=0;
		}
		for(int i=0;i<n;++i) {
			scanf("%d",&tem);
			a[tem]++;     //存储出现的次数
			a2[tem]=i+1;        //存储在原来序列中的下标
		}
		for(int i=1;i<=n;++i) {
			if(a[i]==1) {
				printf("%d\n",a2[i]);
				s=1;
				break;
			}
		}
		if(!s) {
			printf("-1\n");
		}
	}
	return 0;
}
//sort都没用，一个O(n)的算法，用sort就升成O(nlogn)了
然后改我原来的破代码
//这个是wa掉的（用了结构体）交的时候想着这把必过呜呜呜
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

struct Node {
    int index,numb;
    int p;
}arr[MAXN];

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        for(int i=1;i<=MAXN;i++) {     //啊Σ(っ °Д °;)っ做了标记的这两个地方，有等于号会wa掉第三个点
            arr[i].p=0;
        }
        for(int i=1;i<=n;i++) {
            int num;
            scanf("%d",&num);
            arr[num].numb=num;
            arr[num].index=i;
            arr[num].p++;
        }
        int flag=0;
        for(int i=1;i<=MAXN;i++) {	//没有等于号又会t掉第四个点   如果把MAXN换成n就又对了   (っ °Д °;)っ到底是怎么肥四啊啊啊啊
            if(arr[i].p==1) {
                printf("%d\n",arr[i].index);
                flag=1;
                break;
            }
        }
        if(!flag) printf("-1\n");
    }
    return 0;
}
//鸽掉，明天看

T4 ： https://codeforces.com/problemset/problem/1454/C
题意：（题目肯定不是这么描述的，自己提炼一下）给出一组数，选择某个数列中存在的数（必须是全部的位置）把这一列数分割成若干组，问最少可以分出几组（不包含选出的数）
	I can't write Chinese.wuwuwu 啊好了，这其实跟题目表述的选择一个数i，每次去掉全部数列中不包含这个数的子列（连续且完整），问最少的操作数后可以使数列中的数全部相同
思路：根据提炼出来的意思只需要找每个数出现了几次，同时注意特殊情况————某个数连续出现，某个数出现在开头或结尾，这两种情况对最后的统计都有影响
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

using namespace std;

int arr[MAXN];
int p[MAXN];

int min(int a,int b) {
    if(a>b) return b;
    return a;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        memset(arr,0,sizeof(arr));
        memset(p,0,sizeof(p));
        int n;
        scanf("%d",&n);
        int _n=n;
        for(int i=1;i<=_n;i++) {
            scanf("%d",&arr[i]);
            if(i!=1) {
                if(arr[i]==arr[i-1]) {     //去掉连续的，看完我都惊了Σ(っ °Д °;)っ，真的学到了学到了
                    i--;
                    _n--;
                }
            }
        }
        for(int i=1;i<=_n;i++) {
            p[arr[i]]++;
        }
        int ans=999999;
        if(_n==1) {
            printf("0\n");
            continue;
        }
        for(int i=1;i<=n;i++) {
            if(p[i]) {
                ans=min(ans,p[i]);       //某个数出现的次数最少，分割出的子列一定最小
            }
        }
        if(arr[1]==arr[_n]) {
            printf("%d\n",min(ans+1,p[arr[1]]-1));     //在一般位置，子列数是频数+1，在开头和结尾（这是同时出现的特殊位置）是频数-1
        }
        else {
            printf("%d\n",min(ans+1,min(p[arr[1]],p[arr[_n]])));     //只出现开头或结尾，子列数就是频数
        }
    }
    return 0;
}

T4 : https://codeforces.com/problemset/problem/1454/D
//这个题qwq没懂
题意：把一个数按因数从小到大分成一串数，必须满足a[i]和a[i-1]有倍数关系。360——>2，180——>2,2,90 90再分分不出来两个有倍数关系的数了
思路：据说是深搜，但是我没看懂
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

ll arr[MAXN];
ll ans;
ll mid[MAXN];				//mid数组相当于一个中间的过渡量

void dfs(ll sum,ll k,ll la) {    //就是深搜！！！我看懂了！！！   la始终是前面那个数
    if(sum%la==0) {			//如果这个得到的这个较大的因数，是之前的那个较小因数的倍数，就判断得到的这个新的序列长度是不是比之前的长
        mid[k]=sum;
        if(k+1>ans) {
            ans=k+1;
            for(int i=0;i<ans;++i) 		//更长就赋值
                arr[i]=mid[i];
        }       
    }
    else return ;			//如果不是倍数，就需要上一个换上一个因数，退回上一级
    
    for(ll i=la;i*i<=sum;i+=la) {			//每次加la，保证现在这个数的较小因数一定是前面那个数倍数
        if(sum%i==0&&i>1) {
            mid[k]=i;				//就是如果找到了一个因数，就先暂且把这个因数放在过渡量的这个数组里
            dfs(sum/i,k+1,i) ;			//然后接着往后找，较大因数继续进行拆分
        }
    }
    return ;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ll n;
        scanf("%lld",&n);
        ans=0;
        dfs(n,0,1);
        printf("%lld\n",ans);
        printf("%lld",arr[0]);
        for(int i=1;i<ans;i++) {
            printf(" %lld",arr[i]);
        }
        printf("\n");
    }
    return 0;
}
//嘤我居然看懂了

T5 ： https://codeforces.com/problemset/problem/1454/E
//直接下一题/(ㄒoㄒ)/~~

T6 ： https://codeforces.com/problemset/problem/1454/F
//不会qwq

Day 3
T1 ： https://codeforces.com/problemset/problem/1461/A
题意：给出两个整数n和k，造一个字符串，这个字符串的长度是n，包含一个长度为k的回文子串；造出来的字符串只能包含字符'a', 'b', 'c'
思路：啊做的时候犹豫了一下下，造一个回文串那岂不是aaaaa/bbbbb/ccccc就完了，结果还真是……
//水题，不用犹豫，敲就是了
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,k;
        scanf("%d%d",&n,&k);
        for(int i=1;i<k;i++) {
            printf("a");      //前面的字符都敲a（b也行）
        }
        for(int i=1;i<=n-k+1;i++) {
            if(i%3==1) printf("a");
            if(i%3==2) printf("b");
            if(i%3==0) printf("c");    //后面的全都abcabcabc循环（这肯定不是回文串啦）
        }
        printf("\n");
    }
    return 0;
}
//题目对回文串没有太大要求，要是要求不能这样造就稍稍麻烦了吧（从前往后到k/2又从后往前，啊也还好）

T2 ： https://codeforces.com/problemset/problem/1461/B
题意：给出n和m分别是矩阵的长和宽，这个矩阵只由'.'和'*'组成，像这样：
.***.   然后要在这个矩阵里找由'*'组成的圣诞树，像这样：           层数可以从1~k，k<=n（矩阵的行数）
*****							   *			*就是一个圣诞树
*****							  ***
*.*.*							 *****
思路：啊看到这题就感觉想到了古早时候做的找细胞的题，呜呜呜不光代码不会打，我连样例都看不懂，结果细看好像也不需要很麻烦的搜索。反正我做的很暴力，╮(╯-╰)╭，这也是没办法的事qwq
      观察发现，这个题它n和m的范围都是500（简直就是暗示要我写暴力），不大，还挺小，够遍历好几遍的了。所以可以先遍历整个矩阵，预处理每个*向左向右分别可以延伸多少个，也就是说最多这个*
      可以做圣诞树的第几层的中心。
      预处理完就可以再遍历一次，选取每一个*作为圣诞树的顶点，题目中甚至给出了第i层*的个数，所以可以从每一个顶点开始直向下走看以这个点为中心位扩展的*是否可以做一层。
      得到最大层数之后，上方的每一层都可以作为一个独立圣诞树最底层，相加得到最终答案。
//思路说的很累赘，代码要更清楚一点
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

char mat[503][503];
int val[505][505];
int ans;
int m,n;

int doit1(int x,int y) {        //进行预处理的部分
    int value=0;
    for(int i=1;y+i<=m&&y-i>=1;i++) {
        if(mat[x][y+i]=='*'&&mat[x][y-i]=='*') {
            value++;
            continue;
        }
        break;
    }
    return value;
}

void doit2(int x,int y) {
    int i=1;
    int _ans=0;
    while(1) {
        if((x+i-1<=n)&&(val[x+i-1][y]>=(i-1))&&(mat[x+i-1][y]=='*')) {   //根据公式计算并判断这一层应该有的*个数
            _ans++;
            i++;
            continue;
        }
        break;
    } 
    for(int i=2;i<=_ans;i++) //_ans是最多层数
        ans+=1;
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        ans=0;
        scanf("%d%d",&n,&m);
        getchar();
        for(int i=1;i<=n;i++) {
            for(int j=1;j<=m;j++)  {
                mat[i][j]=getchar();
                if(mat[i][j]=='*') ans++;
            }
            getchar();
        }

        for(int i=1;i<=n;i++) 
            for(int j=1;j<=m;j++) 
                if(mat[i][j]=='*') val[i][j]=doit1(i,j);

        /*for(int i=1;i<=n;i++) { 
            for(int j=1;j<=m;j++) 
                printf("%d ",val[i][j]);
            printf("\n");
         }*/

        for(int i=1;i<=n;i++) 
            for(int j=1;j<=m;j++) 
                if(mat[i][j]=='*') doit2(i,j);

        printf("%d\n",ans);
    }
    return 0;
}
//我也没想到还怪长的

T3 ： https://codeforces.com/problemset/problem/1461/C
题意：给定一个长度为n的数组，给出q个操作(r,p), 对[1,r] 区间进行有序排序，排序的概率是p，不变的概率自然就是1−p。问最后数组全部有序的概率是多少。
思路：啊没看懂题啊其实（现在也不咋懂），但是好像是个数学题。
      不懂不懂不懂！！！
      啊啊啊啊糙我看懂了还是要自己看题啊啊啊啊啊
题目的意思我展开说说，就是有一个长度为n的数字序列，我要对它进行m次操作，每一次操作有这样的两个参数，一个针对操作范围，一个针对操作结果，[r,p]，r可以看作每次对数字序列的1~r个数字进行
操作，别管是啥操作，反正我动了一下，然后结果是有q的概率我这几个数变的有序，1-q的概率这几个数的位置不变。然后继续进行下一项操作，对另外几个数再进行类似的操作。
6 5			//给出一个样例，这样长度为6的数字序列进行5个操作
1 3 2 4 5 6		//之前有个疑惑，以为就是给出一个操作之后[1,r]的概率是这样这样，所以迷惑[6,0.7]为啥不直接是答案
4 0.9			//啊就是要操作5次的啊是所以是一个要算的概率的数学题
5 0.3			//是所以说可以跟着这个样例来跑一遍
2 0.4			//诶第一个是有0.9的概率变化前4个，前四个变化对整个数列是否有序是有贡献的。然后是对前5个数操作，这跟上一步对前4个数的操作是有区别的，就是如果上一个操作让前几个数
6 0.7			//变得有序和不变对这一步操作有影响，再往下几步就要分的情况更多，如果按每一步都让让数列变得有序的话，因为要考虑上一个操作完成后的状态。
3 0.5			//所以就正难则反，就假如做完这所有的步骤，我无序，也就是不变，然后最终有序的概率就是1-Q
//然后再继续看，拿这个例子来说的话，因为我最终排好序的序列和初始序列只有前三个不一样，所以说第三个操作，对前两个数进行操作，概率其实是无所谓的，就是我无论前两个数变化还是不变，对整个
//操作，第四个操作我要考虑第三个操作后的状态，而第三个操作完数列还是无序的，那么我第四个操作就不需要对上一步结果分类讨论，因为变不变都是一样的
//啊所以一通乱分析下来，只有初始序列和排好序之后的序列从后往前比第一个不一样的数及其之后的数的操作会影响最终概率
定语十分冗长，代词无比模糊，还是上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 100007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,m;
        int arr[MAXN]={0};
        int _arr[MAXN]={0};
        scanf("%d%d",&n,&m);
        for(int i=1;i<=n;i++) {
            scanf("%d",&arr[i]);
            _arr[i]=arr[i];
        }
        sort(_arr+1,_arr+n+1);  
        int mark=0;
        for(int i=n;i>=1;i--) 
            if(arr[i]!=_arr[i]) {
                mark=i;
                break;
            }
        double ans=1;
        for(int i=1;i<=m;i++) {
            int r;
            double p;
            scanf("%d%lf",&r,&p);
            if(r>=mark) ans*=1.0-p;     //就每次操作后都都不变
        }
        ans=1.0-ans;      //1-无序=有序
        if(mark==0) printf("1.000000\n");
        else 
            printf("%.6lf\n",ans);
    }
    return 0;
}

T4 ： https://codeforces.com/problemset/problem/1461/D
题意：给出一个长度为n的数字序列，然后以mid=（min+max）/2为分界线，把原本的数字序列分成两部分，left=[min,mid],right=(mid,max],再把left和right两个数组按照类似的方式分别分成两部分，每次
      分完各个得到的子序列会得到一个和。然后进行m次询问，每次输入一个数，如果这个数是在操作过程中会得到的和数，就输出YES，否则输出No。
思路：完了这题我现在又不会了。
      第一反应是线段树，就是从小到大排列后把一次分裂得到的两个子序列分别作为一个节点的两个子节点，然后再查询
      //但是因为线段树暂时还没学会呜呜呜没写成
      起码是想到了排序和用upper_bound()或lower_bound()找mid的序号
      反应过来其实不需要做线段树
      就找到了mid的索引，那就可以得到某个子序列的左边界和右边界，前导和就可以直接算出这一段区间的和，那就可以算出可以得到的所有的和了嘛
      //啊暂且算这是思路叭
上代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 100007

using namespace std;

ll arr[MAXN]={0};
ll sum[MAXN]={0};
map<ll,ll> ans;        //之后再说

void doit(int l,int r) {      //处理每一个和是否出现过
    int mid=(arr[l]+arr[r])/2;
    ans[sum[r]-sum[l-1]]=1;
    int pos=upper_bound(arr+l,arr+r+1,mid)-arr;
    if(pos<=r) {
        doit(l,pos-1);
        doit(pos,r);
    }
    return ;
}

void solve() {
    ans.clear();    
    arr[MAXN]={0};
    sum[MAXN]={0};
    int n,q;
    scanf("%d%d",&n,&q);
    for(int i=1;i<=n;i++) {
        scanf("%lld",&arr[i]);
    }
    sort(arr+1,arr+n+1);
    for(int i=1;i<=n;i++) {
        sum[i]=sum[i-1]+arr[i];      //前导和
    }
    doit(1,n);
    ll x;
    while(q--) {
        scanf("%lld",&x);
        if(ans[x]==1) printf("Yes\n");
        else printf("No\n");
    }
}

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        solve();
    }
    return 0;
}

T5 ： https://codeforces.com/problemset/problem/1461/E
https://vjudge.net/contest/416896#problem/E
我肯定不会啦hhhhh

Day 4  //好几天份的不想学习

T1 : https://codeforces.com/problemset/problem/1451/A
题意：给出一个数，然后对这个数可以让它除一个不是它本身的因数，或者让它减一，输出让这个数变成1的操作数
思路：很好想其实，偶数可以直接除 除2得到的 商，然后减去1，变成1；奇数的话就减去1变成偶数，然后做对偶数做的操作。
      然后就是非常显而易见的特殊情况，这个数本来就是1，这个数本身就是2，这个数减去1后变成的偶数是2
代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<algorithm>

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n;
        scanf("%d",&n);
        if(n==1) {
            printf("0\n");
            continue;
        }
        if(n==2) {
            printf("1\n");
            continue;
        }
        if(n==3||n%2==0) {
            printf("2\n");
            continue;
        }
        if(n%2==1) {
            printf("3\n");
            continue;
        }
    }
    return 0;
}
//水题实锤

T2 ： https://codeforces.com/problemset/problem/1451/B
题意：给出一串只有0和1 的数字串长度为n，然后是m组测试数据，每一组测试数据有两个数l和r，以这两个数为开头索引和结束索引会得到一个原来数字串的子串，判断是否可以在原来序列里找到一个子序列（
      （索引可以不连续），它的每一个字符在原来序列里对应的索引和测试数据不全相等。
思路：还是要找最低要求，连最低的要求都可以满足，那一定满足题意。那最低要求是什么嘞？中间的字符都取测试数据给的子串，开头和结尾的字符在其他位置找（顺序不能变化），第一个字符往前找，最
      后一个字符往后找。
//不难，好好想想
上代码：
#include<iostream>
#include<algorithm>
#include<iomanip>
#include<set>
#include<queue>
#include<stack>
#include<vector>
#include<map>
#include<cstring>
#include<string>
#include<cmath>
#include<cstdio>
typedef long long ll;
using namespace std;
int main() {
	int t;
    scanf("%d",&t);
	while(t--)
	{
		int n,q;
        scanf("%d%d",&n,&q);
		string s;
        cin>>s;
		while(q--)
		{
			int l,r;
            scanf("%d%d",&l,&r);
			l--;r--;
			int flag=0;
			for(int i=0;i<l;i++)
			    if(s[i]==s[l])  flag=1;
			for(int i=r+1;i<n;i++)
			    if(s[i]==s[r])  flag=1;
			if(flag) cout<<"YES"<<endl;
			else cout<<"NO"<<endl; 
		}
	} 
	return 0;
}

莫名其妙wa掉的代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

int main() {
    int t;  
    scanf("%d",&t);
    while(t--) {
        int n,q;
        char ch[111];
        scanf("%d%d",&n,&q);
        fflush(stdin);
        scanf("%s",ch);
        for(int i=1;i<=q;i++) {
            int ll,r;
            scanf("%d%d",&ll,&r);
            int flag=0;
            for(int j=0;j<ll-1;j++) {
                if(ch[j]==ch[ll-1]) {
                    flag=1;
                    break;
                }
            }
            for(int j=r;j<n;j++) {
                if(ch[j]==ch[r-1]) {
                    flag=1;
                    break;
                }
            }
            if(flag) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}

莫名其妙Re的代码：
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 200010

using namespace std;

int main() {
    int t;  
    scanf("%d",&t);
    while(t--) {
        int n,q;
        char ch[111];
        scanf("%d%d",&n,&q);
        //fflush(stdin);
        scanf("%s",ch);
        for(int i=1;i<=q;i++) {
            int le,r;
            scanf("%d%d",&le,&r);
            int flag=0;
            for(int j=0;j<le-1;j++) {
                if(ch[j]==ch[le-1]) {
                    flag=1;
                    break;
                }
            }
            for(int j=r;j<n;j++) {
                if(ch[j]==ch[r-1]) {
                    flag=1;
                    break;
                }
            }
            if(flag) printf("YES\n");
            else printf("NO\n");
        }
    }
    return 0;
}
//淦噢我一时竟然不知道该问fflush到底怎么用还是一个地方的bug两次报的错不一样？？
//好叭以后还是老老实实getchar()

T3 ： https://codeforces.com/problemset/problem/1451/C
题意：给出a串和b串，将b串视为标准串，对a串做以下两种操作，判断若干次后是否可以将a串变为b串：
	  1.如果a串有连续k个字符相同，可以把这k个字符的ASCII码值加一变为另一个字符
	  注：k是输入的常数，只可以+1，并且不能循环，也就是'z'+1不是'a'
	  2.交换任意相邻的两个字符
思路：下面是给的一组测试数据，第一个数字是字符串长度第二个字符是k的值
3 3	  很误导我啊真的是这个数据，这个题也真的要好好想的┭┮﹏┭┮
abc   看完第一组：噢好像啥也没看出来，是要把两组相同的字符放在相同索引的位置吗？然后判断不一样的可不可以继续操作，但是没法放啊
bcd				 
4 2	//然后就看第二组哈
abba	//第一反应：啊排序，两个字符串一样的会对应起来然后比较不一样的是不是有连续k个能不能换就好啦
azza
2 1
zz	
aa
6 2
aaabba		//完全不对嘤嘤嘤这个可以是把a放在了一起然后a和d对应了一下，b和c对应了一下，分别加上几。那所以就是把数目一样的放在一起！
ddddcc		//所以给了一个思路是计算每一个字母的数目然后把一样的对应起来看能不能换，然后可能有剩下的，就继续看能换吗（诶试试呗）
那就更麻烦了，因为存在就是好几个字母一样，一个能换可能会导致另一个换不掉（吗），复杂度有点高？
//我的智障思路写出来的奇怪代码，没法往下写根本，因为不知道这样一直找一样的啥时候能结束啊
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include<bits/stdc++.h>

#define ll long long
#define MAXN 1e5+7

int main() {
	int t;
	scanf("%d",&t);
	while(t--) {
		int n,k;
		scanf("%d%d",&n,&k);
		getchar();
		int a[30]={0},b[30]={0};
		for(int i=1;i<=n;i++) {
			int ch=getchar();
			a[ch-'a'+1]++;
		}
		getchar();
		for(int i=1;i<=n;i++) {
			int ch=getchar();
			b[ch-'a'+1]++;
		}
		int flag=0;
		for(int i=1;i<=26;i++) {
			if(a[i]<=b[i]&&a[i]) {     //相同的字母，b串比较多，说明必须有a串别的若干个相连的字母换过来但是不能减只能加
				printf("No\n");
				flag=1;
				break;
			}
			if(a[i]>=b[i]&&b[i]) {   //相同的字母，a串比b串多，说明a串所有的字符都必须转换为其他字母
				a[i]-=b[i];
				b[i]=0;
				if(a[i]%k!=0) {      //必须连续k个相同的字符才能转换，如果不能
					flag=1;
					printf("No\n");
					break;
				}
			}
			//b串里没有这样的字母那就找个数一样的（啊啊啊啊为啥跟刚刚说好的不一样） 
			//我觉得也许应该重新起一个循环？
			for(int i=1;i<=26;i++) {
				if(a[i]) {    //如果还有没变完的，就要找个数一样的（如果没有咋办）
//写到这发现好像写不下去了，因为找完一样的还可能有剩下的，就算是找大于等于的，减完还可能有剩下的，就一片混乱
//还是专注一下这个AC代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 100007

using namespace std;

int main() {
    int t;
    scanf("%d",&t);
    while(t--) {
        int n,k;
        scanf("%d%d",&n,&k);
        getchar();
        int a_num[30]={0};
        int b_num[30]={0};
        for(int i=1;i<=n;i++) {
            a_num[getchar()-'a'+1]++;
        }
        getchar();
        for(int i=1;i<=n;i++) {
            b_num[getchar()-'a'+1]++;
        }
        getchar();					//这一部分依旧是统计了各个字母的数量
        int flag=0;
        for(int i=1;i<=26;i++) {				//这个的思路是一个一个挨着换，我最后统计个数就相当于是把相同的字母放在了一起，而且排了序
            if(a_num[i]<b_num[i]) {				//如果我一样的字母目的串比较多，a串就不可能变出这么多这个字母
                printf("No\n");					//所以我最后一定变不出来目的串
                flag=1;							//（这部分我的智障代码也有）
                break;
            }
            if(a_num[i]==b_num[i]) continue;		//如果我同一个字母恰好两个串个数一样，那就不需要做变化了嘛，直接下一个
            if(a_num[i]>b_num[i]) {					//如果我a串这个字母比较多，那我多的字母肯定是要填给其他不够的字母，那我怎么找这个要填的呢
                if(i==26) {							//特判，如果恰好推到最后一个多了，那就说明肯定有一个配不成（但是我咋觉得这种情况不会出现呢）
                    printf("No\n");					//我一直往后推最后前面的都一样了（划掉），会出现的会出现的
                    flag=1;
                    break;
                }
                int dis=a_num[i]-b_num[i];			//干脆就没有找，直接推给了下一个，如果下一个还要多，就相当于是填给了下下一个，反正最后肯定能找到需要的那个
                if(dis%k!=0) {						//如果我多的个数不是k的倍数，那最终填的话总有剩的这个字母，所以肯定也变不成一样的
                    printf("No\n");					//（这一part我的智障代码居然也有）
                    flag=1;
                    break;
                }
                a_num[i+1]+=dis;					//直接推给下一个
            }
        }
        if(!flag) printf("Yes\n");
    }
    return 0;
}

