Day1 
//今天份的不想学习
//只做了四道题，剩下一道图论一道线性规划之后补

T1 ： https://codeforces.com/problemset/problem/1472/A
题意：给出纸张的长和宽，只有偶数可以继续裁剪。最终能够得到的纸张数是否大于等于指定数目。
思路：很显然最终可以得到的纸张数=裁剪“长” * 裁剪“宽”， 转化为求一个偶数最终能够分为几个奇数————一直除2看能除几次，然后根据（我没有的）数学知识是求2的次幂，怕卡时间写了快速幂
//也不知道说的啥，上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

long long ans;
long long poww;
long long h, w, n;
int t;

long long kpow(long long _poww) {     //变量名实在太丑了点
    long long _ans=1;
    long long b=2;
    if(_poww==0) {
        _ans=1;
        return _ans;
    }
    while(_poww>0) {
        if(_poww&1) 
           _ans=_ans*b;
        b=b*b;
        _poww=_poww>>1;
    }
    return _ans;    //这是快速幂的部分（无情的模板机器
}

long long doit (long long x) {
    poww=0;
    while(!(x&1)) {        //位运算稍微快一点点
        x=x>>1;
        poww++;            //这个是看可以除几次2
    }
    return kpow(poww);
}

int main() {
    scanf("%d", &t) ;
    for(int i = 1; i <= t; i ++) {
        scanf("%lld%lld%lld", &w, &h, &n);
        ans = doit(w) * doit(h);
        if(ans >= n) {
            printf("YES\n");
            continue;
        }
        printf("NO\n");
    }
    return 0;
}
//啊签到题罢辽(但是说不定还有简单做法？

T2 ： https://codeforces.com/problemset/problem/1472/B
题意：给出一串只有1和2的序列，判断是否可以把这个序列分成两个子序列，使两个子序列的所有数之和相对（我也不知道在说啥反正就这个意思
题解：突破点其实在这一串数只有1和2来着（一开始没看见吓死了），稍微要想一下。如果这一串数满足，应该有以下几点特征：
      1.所有数之和不能是奇数，必须是偶数
      //然后思考如果是偶数就一定满足了吗？
      //和是偶数的话，说明1的数量一定是偶数，2的数量可能是奇数可能是偶数。
      //如果2的数量是偶数，那就一定可以，最起码存在两组分别有一半1和一半2；如果2的数量是奇数，设2的数量是y,1的数量是x,满足要求的话也就是2y-x可以对半分，啊那就显然可以。
      //然后注意特殊情况，1的数量是0的话，2的数量是奇数也不行
      2.1的数量为0时，2的数量不能是奇数

//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define MAXN 100010

int t;
int n;
int w[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        scanf("%d",&n);
        int two=0;
        int one=0;
        int ww=0;
        for(int j=1;j<=n;j++) {
            scanf("%d",&w[j]);
            if(w[j]==1) one++;
            if(w[j]==2) two++;
            ww+=w[j];
        }
        if(ww%2==1) {
            printf("NO\n");
            continue;
        }
        if((one==0)&&two%2!=0) {
            printf("NO\n");
            continue;
        }
        printf("YES\n");
    }
    return 0;
}
//稍微还是有点难想吧，题做多了可能敏感度就上来了（？）

T3 ： https://codeforces.com/problemset/problem/1472/C
题意：给出数字序列，下标从1开始，随机选一个下标i开始走，value加上a(i),下一步走到i+a(i),直到走到没法再走。要找出这个下标，使结束时的value最大。
思路：第一反应可能是模拟，一个一个扫过去，但是时间复杂度就很高。所以想到倒推，value[i]=a[i]+value[i+a[i]]
//上代码
#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<math.h>
#include<string>
#include<algorithm>
#include<cstring>
#define MAXN 200010

int t=0;
int n=0;
int a[MAXN];
int dp[MAXN]={0};
int ans=0;

int max(int a,int b) {
    if(a>b) return a;
    return b;
}

int main() {
    scanf("%d",&t);
    while(t--) {
        scanf("%d",&n);
        for(int i=1;i<=n;i++) {
            scanf("%d",&a[i]);
        }
        ans=0;
        for(int i=n;i>=1;i--) {
            if(i+a[i]<=n) {
                dp[i]=a[i]+dp[i+a[i]];      //并不是动规，稍微被误导了以下
            }
            else {
                dp[i]=a[i];
            }
            ans=max(ans,dp[i]);
        }
    printf("%d\n",ans);
    }
    return 0;
}
//不太难，偶尔还是要自己想一想感受一下脑子的存在

T4 ： https://vjudge.net/problem/CodeForces-1472D/origin
题意：奇偶游戏。Alice选偶数加分，Bob选奇数加分，同时两人也可以ban掉对方选的数，当两人最佳发挥时，谁可以最终赢得比赛。
思路：首先思考最佳发挥是怎么发挥法。Alice要总能选到对自己有利的数，每一回合要决定pick还是ban，最终的目的是赢，贪心看，比较pick的数较大还是ban的数较大，就可以确定是ban还是pick；Bob同理。
      所以要对偶数和奇数分别进行排序，然后从大向小遍历。
//还是简单粗暴的上代码写注释

#include<iostream>
#include<bits/stdc++.h>
#include<cstdio>
#include<cmath>
#include<string>
#include<algorithm>
#include<cstring>

#define ll long long
#define MAXN 200010

using namespace std;

int t;
ll totA,totB;
ll jishu[MAXN],oushu[MAXN];

int main() {
    scanf("%d",&t);
    for(int i=1;i<=t;i++) {
        int n;
        scanf("%d",&n);
        int ji=1,ou=1;
        for(int j=1;j<=n;j++) {
            ll num;
            scanf("%lld",&num);
            if(num%2==1) {
                jishu[ji]=num;        //奇数和偶数分别放在不同的数组里
                ji++;
            }       
            else {
                oushu[ou]=num;
                ou++;
            }
        }
        sort(jishu,jishu+ji);
        sort(oushu,oushu+ou);
        ji--;
        ou--;   
        totA=0;
        totB=0;
        for(int j=0;j<n;j++) {
            if(j%2==0) {   //Alice的回合
                if((ou==0)&&(ji>0)) {    //如果偶数已经选完，那现在势必是要ban掉奇数
                    ji--;
                    continue;
                }
                if(jishu[ji]<oushu[ou]) {    //如果没有选完，并且pick比ban更有利
                    totA+=oushu[ou];
                    ou--;
                }
                else {
                    if(ji>0) ji--;
                }
                //printf("%lld\n",totA);
            }
            else {
                if((ji==0)&&(ou>0)) {     //Bob同理
                    ou--;
                    continue;
                }
                if(jishu[ji]>oushu[ou]) {
                    totB+=jishu[ji];
                    ji--;
                }
                else {
                    if(ou>0) ou--;
                }
            }
        }
        if(totA>totB) printf("Alice\n");
        if(totA<totB) printf("Bob\n");
        if(totA==totB) printf("Tie\n");
    }   
    return 0;
}

//稍微想一下下，关键在怎么才是最佳发挥

T5 ： https://vjudge.net/problem/CodeForces-1472E/origin
//这个是后来补的题
题解：就是给出几个矩形的长和宽，然后判断这个矩形是否可以将某个矩形完全覆盖（不包含等号），如果可以就输出被覆盖的矩形的索引，如果没有，就输出-1.
思路：题目中说给出的矩形的“长”和“宽”不一定哪个大，啊啊不知道怎么说。反正根据小学生思维，大的就看作长，小的就看作宽，那其实就无所谓比较的方法了（题目里说的站着或躺着），






















