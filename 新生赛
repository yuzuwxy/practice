描述
给定一个整数n，将数字1~n排成一排，将会有很多种排列方法。现在，请你按照字典序将所有的排列方法输出。
输入
共一行，包含一个整数n(1≤n≤7)
输出
按字典序输出所有排列方案，每个方案占一行。
输入样例 1 
3
输出样例 1
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
//完犊子自己写的搜索回溯（也许是？） 账号密码忘了代码还得重写呜呜呜
//自己认真写的搜索回溯了叭，第一次写还感觉有点困难，第二次就很顺啦，写完调完也就十分钟吧
#include<iostream>
#include<cstdio>

using namespace std;

int n;
int a[10];
bool fnum[10];

void print() {
	printf("%d",a[1]);
	for(int i=2;i<=n;i++)
		printf(" %d",a[i]);
	printf("\n");
}

void array(int cnt,int pos) {
	if(pos==n) {
		a[n]=cnt;   //到了最后一个数了
		print();    //可以输出了
		return;     //返回上一层
	}
	a[pos]=cnt;
	fnum[cnt]=1;    //把这个数字放在这个位置并标志已经排过
	for(int i=1;i<=n;i++) 
		if(fnum[i]==0) {    //这个数字还没有放过，可以排进队里
			array(i,pos+1);
			fnum[i]=0;    //这个数字的情况排在这个位置的情况讨论之后需要对状态重置
		}
}

int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++) {  //会有1，2，3，……打头的情况
		memset(fnum,0,sizeof(fnum));//最开始写在了函数退出的if里（肯定是错的啦），每次换一个排头，就代表顺序全部乱一次，要重新排
		array(i,1);//既然已经决定了把数列全都排好后放在一个数组里输出，就需要标记数组的位置也就是下标啦，所以得在函数中数带着位置走
	}
	return 0;
}

以及为什么排出来一定是字典序？
因为对数的遍历是按照顺序来的，最先遇到的没有放置过的数一定是满足要求最小的，然后才往大的放


描述
翰翰和达达饲养了N只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了（呜咕>_<）。
翰翰和达达只好花钱让它们坐索道下山。索道上的缆车最大承重量为W，而N只小猫的重量分别是C1、C2……CN。当然，每辆缆车上的小猫的重量之和不能超过W。
他们想知道，最少需要多少辆缆车才能把这N只小猫都运送下山？

输入
第1行：包含两个用空格隔开的整数，N和W。第2..N+1行：每行一个整数，其中第i+1行的整数表示第i只小猫的重量Ci。

输出
输出一个整数，表示最少需要多少辆缆车。

输入样例 1 
5 1996
1
2
1994
12
29
输出样例 1
2
提示
数据范围1≤N≤18,1≤Ci≤W≤10^8 
//做的时候想过贪心，就是尽量先把小的放进去，然后马上找到了反例（非常容易，就懒得举例了
//然后就觉得万一是动规呢，就没做了qwq
//正解可以这样，之前想的贪心再往前想一步就好了，唉
//就是说先放小的进去可能会导致小的全部放进去之后的大的放不进去现在这个只能再找一个，这就可能使小的其实可以跟大的塞到一起但是又另外加了一个缆车导致资源浪费费用增加
//那么是不是可以先放大的进去，然后找可以塞缝的小的
//代码如下：
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<string>
#include<algorithm>

using namespace std;

int n,w;
int cats[25];
bool fcats[25];

int main() {
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++) 
		scanf("%d",&cats[i]);
	sort(cats+1,cats+n+1);
	int ans,rem;
	ans=0;
	rem=0;
	//要先把大的放进去
	for(int i=n;i>=1;i--) {
		if(rem<cats[i]) {
			ans++;
			rem=w-cats[i];
			fcats[i]=1;
		}
		while(1) {
			int x=upper_bound(cats+1,cats+n+1,rem)-cats;   //找到的是第一个大于rem的值（源代码是二分）
			x--;   //得到的是第一个小于等于rem的量的下标
			while(fcats[x]&&x>0) x--;
			if(x==0) break;
			rem-=cats[x];
			fcats[x]=1;
		}
	}
	printf("%d\n",ans);
	return 0;
}

//然后WA掉了
//为什么会WA掉！！！！！！


//我计导考完了！！！！
#include<cstdio>
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
#include<stack>
#include<set>
#include<map>
#include<vector>
#include<cmath>
const int maxn=1e5+5;
typedef long long ll;
using namespace std;
int a[20],car[20],ans;	
int n,w;
bool cmp(int x,int y){//搜索顺序优化 
	return x>y;
}
void dfs(int now,int count){
	if(count>=ans)//剪枝 
	    return ;//已经没有必要了 
	if(now>=n+1){
		ans=min(count,ans);
		return ;
	}//满足条件，更新 
	for(int i=1;i<=count;i++){
		if(car[i]+a[now]<=w){//能装下 
		    car[i]+=a[now];
			dfs(now+1,count);
			car[i]-=a[now];			
		}		     
	}
	car[count+1]=a[now];//装不下了，再要一辆车 
	dfs(now+1,count+1);
	car[count+1]=0;
}
int main(){
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++)
		scanf("%d",&a[i]);
	sort(a+1,a+n+1,cmp);//预先排一下序 
	ans=n;//最多的可能就是一个猫一个车 
	dfs(1,0);//入口 
	printf("%d\n",ans);
	return 0;
}


//又是一个不知道为什么但是WA掉的代码
#include<iostream>
#include<cstdio>
#include<cmath>
#include<algorithm>
#include<string>
#include<cstring>
#include<bits/stdc++.h>

using namespace std;

int n,w;
int a[20],f[20];
//数组f用来放每个筐里已经装的猫的重量
int ans,sum;
bool flag=0;

int cmp(int x,int y) {
	return x>y;
}//即将猫的重量升序排序

void dfs(int x) {    //深度优先搜索，把第x只猫装进来了
	if(x==n+1) { //因为第i只猫装完直接搜第i+1只猫，所以判断终点是n+1
		flag=1;
		return;
	}//深度优先搜索，最先到的一定是最可行的
	for(int i=1;i<=ans;i++) {  //开始往这么多筐里一只一只装猫
		if(f[i]+a[x]<=w) {  //如果这个筐里还能装
			f[i]+=a[x];   //暂且先装进去
			dfs(x+1);  //装下一只 
			//装完回来觉得不行
			f[i]-=a[x]; //就不往这个筐里装
			if(flag) return;
		}
	}
	return ;
}

int main() {
	scanf("%d%d",&n,&w);
	for(int i=1;i<=n;i++) {
		scanf("%d",&a[i]);
		sum+=a[i];
	}
	sort(a+1,a+n+1,cmp);   
	for(ans=sum/w;ans<=18;ans++) {    //最少需要的框就是每一个都正正好装满，最多也不过是每个框只装一个
		memset(f,0,sizeof(f));       //开始判断这么多框能不能装得下，刚开始每只猫都没被装进去
		dfs(1);     //也许是装了第一只猫进去的意思？
		//flag=0;
		if(flag==1) {     //如果可行
			printf("%d\n",ans);
			break;
		}
	}
	return 0;
}
//亏我仔细写了很久的注释呜呜呜
